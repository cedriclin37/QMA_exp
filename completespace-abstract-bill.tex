\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{times}
\usepackage{epsfig}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}

\usepackage{varioref}
\usepackage{verbatim} 
\usepackage{multicol}
\usepackage{lmodern}
\usepackage{enumerate}
%\usepackage[normalem]{ulem}
%
%\usepackage{caption}
%\usepackage{subcaption}
%\usepackage[T1]{fontenc}
%\usepackage[margin=1in]{geometry}
%\usepackage{fancyhdr}
%\usepackage{authblk}
%
%\usepackage{thm-restate}
%
\usepackage{mathrsfs}

\usepackage{hyperref}
\hypersetup{
    bookmarksnumbered=true, % If Acrobat bookmarks are requested, include section numbers
    unicode=false, % non-Latin characters in Acrobat bookmarks
    pdfstartview={}, % fits the width of the page to the window
    pdftitle={}, % title
    pdfauthor={}, % author
    pdfsubject={}, % subject of the document
    pdfcreator={}, % creator of the document
    pdfproducer={}, % producer of the document
    pdfkeywords={}, % list of keywords
    pdfnewwindow=true, % links in new window
    colorlinks=true, % false: boxed links; true: colored links
    linkcolor=blue, % color of internal links
    citecolor=blue, % color of links to bibliography
    filecolor=blue, % color of file links
    urlcolor=blue % color of external links
}

\newcommand{\classfont}{\sf}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}[lemma]{Theorem}
\newtheorem{corollary}[lemma]{Corollary}
\newtheorem{definition}[lemma]{Definition}
\newtheorem{proposition}[lemma]{Proposition}
\newtheorem{question}{Question}
\newtheorem{conjecture}{Conjecture}
\newtheorem{condition}{Condition}

\newtheorem{claim}{Claim}
\newtheorem{example}{Example}
\numberwithin{lemma}{section}
%\numberwithin{definition}{section}
%\numberwithin{question}{section} \numberwithin{claim}{lemma}
\newenvironment{restate}[1]{\bigskip \noindent {\bf #1 (restated).} \it}{\smallskip}

\theoremstyle{definition}
\newtheorem{remark}[lemma]{Remark}

\newcommand\PH{\sf{PH}}
\newcommand\BQP{\sf{BQP}}
\newcommand\PQP{{\sf{PQP}}}
\newcommand\PostBQP{{\sf{PostBQP}}}
\newcommand\NP{\sf{NP}}
\newcommand\MA{\sf{MA}}
\newcommand\AM{\sf{AM}}
\newcommand\PP{\sf{PP}}
\newcommand\BQSPACE{\sf{BQSPACE}}
\newcommand\PSPACE{\sf{PSPACE}}
\newcommand\Poly{\sf{P}}
\newcommand\EXP{{\sf{EXP}}}
\newcommand\DET{{\sf{DET}}}
\newcommand\Logspace{{\sf{L}}}
\newcommand\DSPACE{{\sf{SPACE}}}
\newcommand\NL{{\sf{NL}}}
\newcommand\preciseQMA{{\sf{preciseQMA}}}
\newcommand\QMA{{\sf{QMA}}}
\newcommand\QCMA{{\sf{QCMA}}}
\newcommand\expQCMA{{\sf{QCMA_{exp,poly}}}}
\newcommand\QCIP{{\sf{QCIP}}}
\newcommand\bigoh{\mathcal{O}}
\newcommand\PLclass{{\sf{PL}}}
\newcommand\C{{\mathbb{C}}}
\newcommand\R{{\mathbb{R}}}
\newcommand\Quat{{\mathbb{H}}}
\newcommand\M{{\mathbb{M}}}
\newcommand\F{{\mathbb{F}}}
\newcommand\Z{{\mathbb{Z}}}
\newcommand\N{\mathbb{N}}
\newcommand\Tr{{\mathop\textup{Tr }}}
\newcommand{\Ext}{E}
\newcommand{\BPL}{{\classfont{BPL}}}
\newcommand{\Unitary}{\mathbf{U}}
\newcommand{\unitaryBQL}{{\classfont{BQL}}}
\newcommand{\unitaryQMASPACE}{{\classfont{QMA}_\Unitary\classfont{SPACE}}}
\newcommand{\unitaryQSPACE}[3]{{\classfont{Q}_\Unitary\classfont{SPACE}}[#1](#2,#3)}
\newcommand{\unitaryBQSPACE}[1]{{\classfont{BQ}_\Unitary\classfont{SPACE}}[#1]}

\newcommand{\rv}[1]{{\mathbf{#1}}}
\newcommand{\pr}[1]{\Pr\left[#1\right]}
\newcommand{\set}[1]{\left\{{#1}\right\}}
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\remove}[1]{}

\renewcommand{\epsilon}{\varepsilon}
\newcommand{\eps}{\epsilon}
\newcommand*\samethanks[1][\value{footnote}]{\footnotemark[#1]}


\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}
\newcommand{\eqdef}{\stackrel{{\rm def}}{=}}

\newcommand{\zo}{\{0,1\}}
\newcommand{\supp}{\mathrm{supp}}

\newcommand{\ee}{\mathcal{E}}
\newcommand{\ii}{\mathbb{I}}
\newcommand{\rl}{\rangle\langle}
\newcommand{\mg}{\mathcal{G}}
\newcommand{\hn}[1]{\|#1\|^H_{1\rightarrow 1}}
\newcommand{\ve}[1]{|#1\rangle\!\rangle}
\newcommand{\ro}[1]{\langle\!\langle#1|}
\newcommand{\bkett}[1]{|#1\rangle\!\rangle\langle\!\langle#1|}
\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\bra}[1]{\langle#1|}
\newcommand{\bk}[1]{|#1\rangle\langle#1|}


\newcommand{\tth}[0]{\textsuperscript{th}}
\newcommand{\st}[0]{\textsuperscript{st}}
\newcommand{\nd}[0]{\textsuperscript{nd}}
\newcommand{\rd}[0]{\textsuperscript{rd}}


\usepackage{xcolor}
\newcommand{\todo}[1]{{\color{red}{[{\bf TODO:}#1]}}}
\newcommand{\skimmel}[1]{{\color{violet}{[{\bf skimmel:}#1]}}}
\newcommand{\wf}[1]{{\color{violet}{[{\bf wf:}#1]}}}
\newcommand{\tocite}[1]{{\color{blue}{[{\bf CITE:}#1]}}}
\newcommand{\tocheck}[1]{{\color{red}{[{\bf TO CHECK:}#1]}}}

\DeclareMathAlphabet{\matheu}{U}{eus}{m}{n}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\id}{id}
\newcommand{\Favg}{\overline{F}}
\newcommand{\Paulis}{{\matheu P}}
\newcommand{\Clifs}{{\matheu C}}
\newcommand{\Hilb}{{\matheu H}}
\newcommand{\T}{{\matheu T}}
\newcommand{\sop}[1]{{\mathcal #1}}
\newcommand{\PL}[1]{{#1}^{P\!L}}
\newcommand{\BHn}{{{\mathcal B}({\mathcal H}^{\otimes n})}}
\newcommand{\I}{{\mathbb I}}
\newcommand{\CNOT}{{\mathrm{CNOT}}}
\newcommand{\plr}[1]{\hat{#1}} %pauli-liouville-represenation

%\newcommand{\ket}[1]{|{#1}\rangle}
%\newcommand{\bra}[1]{\langle{#1}|}
\newcommand{\braket}[2]{\langle{#1}|{#2}\rangle}
\newcommand{\ketbra}[2]{|{#1}\rangle\!\langle{#2}|}
\newcommand{\kket}[1]{|{#1}\rangle\!\rangle}
\newcommand{\bbra}[1]{\langle\!\langle{#1}|}
\newcommand{\bbrakket}[2]{\langle\!\langle{#1}|{#2}\rangle\!\rangle}

\newcommand{\no}{\nonumber\\}
\newcommand{\even}{_\textrm{even}}
\newcommand{\odd}{_\textrm{odd}}

\newcommand{\ns}{{\textsc{ns}}}
\newcommand{\ceil}[1]{\left\lceil{#1}\right\rceil}
\newcommand{\se}{\succcurlyeq}
\newcommand{\di}{\textrm{diag}}
\newcommand{\orcl}{{\pmb{\sop O}}}
\newcommand{\porcl}{{\pmb{\sop P}}}
\newcommand{\SA}{{\mathbf{S}_X^n}}
\newcommand{\SB}{{\mathbf{S}_Y^n}}
\newcommand{\Si}{{\mathbf{S}_1}}
\newcommand{\Sj}{{\mathbf{S}_2}}
\newcommand{\SU}{{S}}
\newcommand{\Ugroup}[1]{\mathbf{U}^{#1}}
\newcommand{\polyn}{\mathrm{poly\:}}
\usepackage{mathtools}
\usepackage{titling}
\newcommand\psham[1]{#1\textit{\sf{-Precise Succinct Hamiltonian}}}
\newcommand\spechamiltonian[1]{#1\textit{\sf{-Minimum Eigenvalue}}}
\newcommand\matrixinversion[1]{#1\textit{\sf{-Well Conditioned Matrix Inversion}}}

\setlength{\droptitle}{-5em}

%\usepackage[hmargin=1.75cm,vmargin=1.0cm]{geometry}
\usepackage[hmargin=.85in,vmargin=.7in]{geometry}
\title{A Complete Characterization of Unitary Quantum Space \\ {\small \bf (3 page abstract)}}
\author{Bill Fefferman\thanks{Joint Center for Quantum Information and Computer Science (QuICS), University of Maryland,
College Park, USA.}
\and {Cedric Yen-Yu Lin\samethanks}}

\date{}
\begin{document}
\vspace{-2.0in}
\maketitle
\setcounter{page}{0}
\thispagestyle{empty}
\pagestyle{empty}
\vspace{-.6in}
\section{Introduction}
%My suggestion: we put all motivation in the introduction and then give proof sketches of the two main results in the next two sections
How powerful is quantum computation with a restricted number of qubits? In this work we give two complete problems for $\BQSPACE[k(n)]$, the class of problems that can be solved by a uniformly generated family of unitary\footnote{In this context a {\emph{unitary}} quantum circuit makes all measurements at the end of the computation.  Note that the standard method for deferring quantum measurements may incur an exponential blow-up in space.} quantum circuits that act on $k(n)$ qubits, for any fixed function $k$ between $\log{n}$ and $\polyn{n}$. To the best of our knowledge these are the first natural complete problems for quantum space-bounded classes.

The first problem we consider, the $\matrixinversion{k(n)}$ problem, is a well-conditioned version of the ubiquitous matrix inversion problem. The second problem we consider, the $\spechamiltonian{k(n)}$ problem, is a natural generalization of the familiar local Hamiltonian problem, and asks us to compute the ground state energy of a sparse Hamiltonian up to exponentially small precision. Interestingly enough, the first (resp. second) problem is the space-bounded variant of a $\BQP$-complete (resp. $\QMA$-complete problem); their complexities coincide in the space-bounded regime.

We now proceed to give some justification for the importance of our results.

\subsection{Computational Complexity Background}
The complexity of the Matrix Inversion problem is a very important question in computational complexity. Matrix inversion is known to be complete for $\DET$, the class of functions as hard as computing the determinant of an integer matrix, which can be solved in classical $\mathcal{O}(\log^{2}(n))$ space \cite{berkowitz, cook}. It is a major open problem to determine if Matrix Inversion can be solved in classical logarithmic space, which would imply $\Logspace=\NL=\DET$.

Recently, Ta-Shma \cite{tashma}, building on work of Harrow, Hassidim, and Lloyd \cite{HHL}, showed that inverting a well-conditioned $n \times n$ matrix can be approximated by a quantum algorithm using $O(\log n)$ space, but with intermediate measurements. Similarly, Ta-Shma also gives an algorithm for computing eigenvalues of a Hermitian matrix with similar space. These algorithms achieve a quadratic advantage in space over the best known classical algorithms, which require $\Omega(\log^2n)$ space.  This is the maximum quantum advantage possible, since Watrous has shown $\BQSPACE[k(n)]\subseteq\DSPACE[\bigoh(k(n)^2)]$ \cite{Watrous99,Watrous03} even for quantum algorithms with intermediate measurements.

Our results improve upon Ta-Shma's result \cite{tashma} in two ways. First, unlike Ta-Shma's result, we show that these problems can be solved without intermediate measurements.  In addition, we show that the problems of inverting well-conditioned matrices and computing minimum eigenvalues of Hermitian matrices are hard for unitary quantum logspace under $\Logspace$-reductions. In other words, one cannot show that well-conditioned matrices are invertible in $\Logspace$ unless one also shows that $\Logspace=\unitaryBQL$, which seems quite unlikely. Interestingly, our algorithm for computing the minimum eigenvalue is very different from Ta-Shma's algorithm.

Concurrently with our work, Doron, Sarid, and Ta-Shma have shown that analogous problems for stochastic matrices (e.g. computing the eigenvalue gap) are complete for classical randomized logspace, or $\BPL$ \cite{dt15,dst16}. In addition, Le Gall has shown that analogous problems for Laplacian matrices can be solved in $\BPL$ \cite{legall16}. Since it is straightforward to see that Well-conditioned Matrix Inversion reduces to Integer Matrix Inversion, we can use our result to obtain a direct proof that $\unitaryBQL\subseteq\DET$, which was previously known indirectly via the containments $\unitaryBQL\subseteq\PLclass\subseteq\DET$ \cite{Watrous03,Borodin84}.

Therefore the power of classical and quantum space-bounded classes are characterized by the ability to approximate solutions of different problems in $\DET$ (stochastic matrices for the former, and Hermitian matrices for the latter). This could shed some light on the differences between deterministic, randomized, and quantum space complexity. An obvious open question is to find a class of interesting matrices whose inverse (or eigenvalues) can be computed in \emph{deterministic} logspace.

\subsection{Relationship with Matchgates}

Matchgates are a subclass of quantum gates introduced by Valiant \cite{Val02SIComp}, who also showed that nearest neighbor matchgate circuits (which we will just call matchgate computations) are classically simulable. Matchgate computations were further shown to be equivalent to a one-dimensional model of noninteracting fermions by Terhal and DiVincenzo \cite{TerDiV02PRA}; and equivalent to quantum logspace by Jozsa, Kraus, Miyake, and Watrous \cite{JozKraMiyWat10RSPA}. Our complete problems therefore elucidate the computational power of noninteracting fermions.

We know that sampling from output distributions of matchgate computations gives us the power of $\BPL$; but what is the computational power of computing exactly the output probabilities of matchgate computations? We conjecture that this computational power corresponds to $\DET$, since amplitudes of noninteracting fermion circuits are related to determinants (and see also the discussion in the previous subsection). It is known that output probabilities of matchgate computations can be exactly calculated by an efficient classical algorithm \cite{JozMiy08RSPA}, which is consistent with our conjecture because $\DET \in \classfont{P}$.

\subsection{Quantum Merlin-Arthur with Small Gap}
A consequence of our proof of completeness for the $\spechamiltonian{k(n)}$ problem is an equivalence between space-bounded quantum computations and quantum Merlin-Arthur proof systems. Here we give this equivalence for the polynomial space case: let $\QMA(c,s)$ denote the set of problems solvable by quantum Merlin-Arthur proof systems that in the YES case accepts with probability at least $c$ (the completeness), while in the NO case accepts with probability at most $s$ (the soundness). Then we show the following:
\begin{theorem} Let $\preciseQMA:= \cup_{c-s \ge 2^{-\poly}} \QMA(c,s)$ denote the variant of $\QMA$ with exponentially small completeness-soundness gap. Then
$\preciseQMA = \PSPACE$.
\end{theorem}

The natural classical counterpart of $\preciseQMA$ is contained in $\NP^{\PP}$: given a classical witness, the verifier runs a classical computation that in the YES case accepts with probability at least $c$, or in the NO case accepts with probability at most $s$, where $c>s$. Note that in the classical case $c - s > \exp(-\poly)$ is automatically satisfied. Since $\NP^{\PP}$ is in the counting hierarchy, the entirety of which is contained in $\PSPACE$ (see e.g., \cite{allenderwagner}), we see that the quantum proof protocol is strictly stronger than the classical one, unless the counting hierarchy collapses to the second level.

We also show that the \emph{local} Hamiltonian problem is $\PSPACE$-complete when the promise gap is exponentially small. This is in contrast to the usual case when the gap is polynomially small, where the problem is $\QMA$-complete. Perhaps more surprisingly, $\preciseQMA = \PSPACE$ is more powerful than $\PostBQP=\PP$, the class of problems solvable with postselected quantum computation \cite{aaronson05}.

Another consequence concerns Projected Entangled Pair States, or PEPS, a natural extension of matrix product states to two and higher spatial dimensions, which can be described as the ground state of certain frustration-free local Hamiltonians \cite{vc04}. Our results show that in the setting of unbounded-error quantum computation, PEPS do not capture the full computational complexity of general local Hamiltonian ground states unless $\PP=\PSPACE$. We leave open the problem of extending this separation to the usual bounded-error situation.

Lastly, we are able to strengthen our characterization to show that $\preciseQMA$ contains $\PSPACE$, even when restricted to having perfect completeness.  This allows us to prove that testing if a local Hamiltonian is frustration-free is a $\PSPACE$-complete problem.
\section{Proof techniques}
%\subsection{$\psham{k(n)}$}
%\begin{definition}
%[$\psham{k(n)}$ problem] \label{def: spechamiltonian}
%Given as input is the size-$n$ efficient encoding of a $2^{k(n)} \times 2^{k(n)}$ PSD matrix $H$, such that % the maximum entry in absolute value 
% $\|H\|_{max} = \max_{s,t}|H(s,t)|$ is at most a constant. Let $\lambda_{min}$ be the minimum eigenvalue of $H$. It is promised that either $\lambda_{min} \le a$ or $\lambda_{min} \ge b$, where $a(n)$ and $b(n)$ are numbers such that $b-a > 2^{-\mathcal{O}(k(n))}$. Output 1 if $\lambda_{min} \le a$, and output $0$ otherwise.
%\end{definition}
%\begin{theorem} \label{thm: spechamiltonian}
%For $\Omega(\log(n)) \le k(n) \le \poly(n)$, $\psham{\mathcal{O}(k(n))}$ is complete for \\ $\unitaryBQSPACE{\mathcal{O}(k(n))}$ under classical reductions using $\poly(n)$ time and $\mathcal{O}(k(n))$ space.
%\end{theorem}
\subsection{$\spechamiltonian{k(n)}$ is $\BQSPACE[k(n)]$-complete}
First we describe the upper-bound, proving containment in $\BQSPACE[k(n)]$.  This proceeds in two parts.  In the first, we show that $\spechamiltonian{k(n)}$ is in $\preciseQMA$ with a unitary verifier that uses $k(n)$ qubits of space.  Denote by $A$ the $2^{k(n)}\times 2^{k(n)}$ matrix encoded by the succinct input.  Arthur asks Merlin to send the minimal eigenstate $|\psi\rangle$ and Arthur runs phase estimation on $e^{-iA}$ and $|\psi\rangle$ with one ancilla qubit.  He measures the ancilla and accepts if he sees the zero outcome.  This is phase estimation with one bit of precision, so it's easy to see that the probability we accept is inverse exponentially higher in the case the minimal eigenvalue is small than in the case it is slightly larger.  Of course, we can't hope to implement $e^{-iA}$ exactly, and for this reason require recently described Hamiltonian simulation methods implementing a Hamiltonian $\tilde{A}$ that approximates $A$ to within error $\epsilon$ using time and space that scales with $\log{(1/\epsilon)}$ (see e.g., \cite{berry14,berry15}).  This precise error is required to preserve the inverse exponential gap we attained in the phase-estimation procedure.  

We're now given a $k(n)$-space bounded $\preciseQMA$ protocol that uses a $k(n)$ qubit witness.  Our goal is to amplify to obtain a new protocol using the same amount of space but with completeness and soundness error exponentially small in the witness length, $k(n)$.  To do this we need to develop {\emph{space-efficient}} $\QMA$ error amplification procedures.  We accomplish this by extending ideas used by the ``in-place'' $\QMA$ amplification of Marriott and Watrous, which does not require Merlin to send additional copies of his state \cite{mw05}.  Once we have this protocol we can consider the same verification procedure run on the maximally mixed state witness.  This protocol is still space-efficient, but doesn't require Merlin to send a witness.  We show that the resulting completeness and soundness bounds are now separated by $2^{-k(n)}$, which allows us to again amplify our protocol using our space-efficient amplification technique.  The time used by the resulting bounded error protocol is exponential in $k$, but crucially uses only $O(k(n))$ qubits of space, establishing our upper bound.

The lower bound, showing $\BQSPACE[k(n)]$-hardness is an application of Kitaev's clock construction \cite{ksv02}.  Using our uniformity condition, it is easy to see that any language in $\BQSPACE[k(n)]$ can be decided with a quantum circuit of size at most $2^{k(n)}$.  We first use our space-efficient  amplification procedure to reduce the error.  Then following Kitaev, we construct a Hamiltonian out of the amplified circuit.  It is straightforward to see that the resulting Hamiltonian is sparse and succinct, and that the ground state energy is inverse-exponentially lower in the case the circuit accepts than in the case it rejects.
\subsection{$\matrixinversion{k(n)}$ is $\BQSPACE[k(n)]$-complete}
Inspired by the results of Harrow, Hassidim, and Lloyd, and Ta-Shma \cite{HHL,tashma}, if we are given the succinct encoding of a $2^{k(n)} \times 2^{k(n)}$ matrix $A$ we can use phase estimation on $e^{-iA}$ to compute the eigenvalues $\lambda$ of $A$ into an auxiliary register.  We implement a unitary transformation which uses this register to ``approximately'' implement the inverse of $A$.  The resulting state is now a superposition of  our desired state, namely one that's proportional to $A^{-1}$ applied to the input, and some orthogonal garbage state.  Using the ``oblivious" amplitude amplification technique we show how to generate a state with constant overlap to the state we desire (see e.g., \cite{berry14,berry15}).  Using space-efficient Hamiltonian simulation methods we can guarantee that the resulting procedure uses no more than $k(n)$ qubits of space.
We establish $\BQSPACE[k(n)]$-hardness using a similar argument to Harrow, Hassidim, and Lloyd, in which given a quantum circuit acting on $k(n)$ qubits we can construct a succinctly described $2^{k(n)}\times 2^{k(n)}$ matrix $A$, so that a single element of $A^{-1}$ is proportional to the success probability of the circuit.  This finishes the proof of our claim.  
%\section{$\matrixinversion{k(n)}$}
%\begin{definition}[\matrixinversion{k(n)}] \label{def: matrix invert}
%Given as input is the size-$n$ efficient encoding of a $2^{k(n)} \times 2^{k(n)}$ positive semidefinite matrix $H$ with a known upper bound $\kappa = 2^{\mathcal{O}(k(n))}$ on the condition number, so that $\kappa^{-1}I\preceq H \preceq I$, and $s,t\in \lbrace 0,1\rbrace^{k(n)}$. It is promised that either $|H^{-1}(s,t)|\geq b$
% or $|H^{-1}(s,t)|\leq a$ for some constants $0 \le a < b \le 1$; determine which is the case.
% \end{definition}
%\begin{theorem} \label{thm: matrix invert}
%For $\Omega(\log(n)) \le k(n) \le \poly(n)$, $\matrixinversion{\mathcal{O}(k(n))}$ is complete for $\BQSPACE{\mathcal{O}(k(n))}$ under classical reductions using $\poly(n)$ time and $\mathcal{O}(k(n))$ space.
%\end{theorem}
%
%%Here the subscript $\Unitary$ means that our quantum computation is unitary: there are no intermediate measurements. 
%In particular, if we take $k = \bigoh(\log n)$ we get the following:
%\begin{corollary}
%The problem of approximating, to $1/\poly(n)$ precision, an entry of the inverse of an $n \times n$ PSD matrix with condition number at most $\poly(n)$ is $\unitaryBQL$-complete under $\Logspace$-reductions.
%\end{corollary}
%
 \bibliographystyle{alpha}
\bibliography{completespace}
\end{document} 