\documentclass[11pt]{article}
\usepackage{etex}
%\usepackage{geometry} % to change the page dimensions
%\geometry{margin=1in} % for example, change the margins to 2 inches all round
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{varioref}
\usepackage{verbatim} 
\usepackage{multicol}
\usepackage{lmodern}


\usepackage{enumerate}
\usepackage[normalem]{ulem}
%\usepackage[margin=1in]{geometry}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\usepackage{authblk}
\usepackage{paralist}

%%%%%%%%%%%%%%%%
%Next two lines change the font!!
\usepackage{mathptmx}
\usepackage{newtxmath}
%%%%%%%%%%%%%%%

\usepackage{mathrsfs}

\usepackage{url}\urlstyle{same}
\usepackage{xspace}
\usepackage{thm-restate}

\usepackage{hyperref}
\hypersetup{
    bookmarksnumbered=true, % If Acrobat bookmarks are requested, include section numbers
    unicode=false, % non-Latin characters in Acrobat bookmarks
    pdfstartview={}, % fits the width of the page to the window
    pdftitle={}, % title
    pdfauthor={}, % author
    pdfsubject={}, % subject of the document
    pdfcreator={}, % creator of the document
    pdfproducer={}, % producer of the document
    pdfkeywords={}, % list of keywords
    pdfnewwindow=true, % links in new window
    colorlinks=true, % false: boxed links; true: colored links
    linkcolor=blue, % color of internal links
    citecolor=blue, % color of links to bibliography
    filecolor=blue, % color of file links
    urlcolor=blue % color of external links
}

%-----------------------------------------------------------------------------%
% Theorem-like environments and related macros:
%-----------------------------------------------------------------------------%


\newtheorem{theorem}{Theorem}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{condition}[theorem]{Condition}
\theoremstyle{definition}
\newtheorem{alg}[theorem]{Algorithm}
\newtheorem{definition}[theorem]{Definition}
\theoremstyle{remark}
\newtheorem*{pr_sk}{Proof Sketch}
\newtheorem*{alg_in}{Input}
\newtheorem*{alg_out}{Output}


\usepackage{tikz} 

\input{Qcircuit}
%\input{macros}
\makeatother


%Bill's complexity class commmands\

\newcommand\EXP{{\sf{EXP}}}
\newcommand\BQL{{\sf{BQ_{U}L}}}
\newcommand\DET{{\sf{DET}}}
\newcommand\PLclass{{\sf{PL}}}
\newcommand\QMA{{\sf{QMA}}}
\newcommand\QCMA{{\sf{QCMA}}}
\newcommand\QSPACE{{\sf{Q_{U}SPACE}}}
\newcommand\QIP{{\sf{QIP}}}
\newcommand\PQSPACE{{\sf{PQ_{U}SPACE}}}
\newcommand\BQSPACE{{\sf{BQ_{U}SPACE}}}
\newcommand\PSPACE{{\sf{PSPACE}}}
\newcommand\BQPSPACE{{\sf{BQ_{U}PSPACE}}}
\newcommand\FPSPACE{{\sf{FPSPACE}}}
\newcommand\PP{\sf{PP}}
\newcommand\expQCMA{{\sf{QCMA_{exp,poly}}}}
\newcommand\NP{{\sf{NP}}}
\newcommand\AM{{\sf{AM}}}
\newcommand\BQP{{\sf{BQP}}}
\newcommand\PostBQP{{\sf{PostBQP}}}
\newcommand\PQP{{\sf{PQP}}}
\newcommand\Logspace{{\sf{L}}}
\newcommand\QCIP{{\sf{QCIP}}}
\newcommand\QMAexp{{\sf{PreciseQMA}}}
\newcommand\bddQMA[5]{{\left(#1,#2\right)}\textit{-bounded }\QMA_{#3}(#4,#5)}
\newcommand\PQPSPACE{{\sf{PQ_{U}PSPACE}}}
\newcommand\revPSPACE{{\sf{revPSPACE}}}
\newcommand\succdet{\textit{Succinct Determinant Checking}}
\newcommand\gappedsucc{\textit{Gapped Succinct Matrix Singularity}}
\newcommand\preciselh{\textit{Precise Local Hamiltonian}}
\newcommand\preciseklh{\textit{Precise }$k$\textit{-Local Hamiltonian}}
\newcommand\preciseilh[1]{\textit{Precise }\ensuremath{#1}\textit{-Local Hamiltonian}}
\newcommand\matrixinvert[1]{{\ensuremath{#1}}\textit{-Well-conditioned Matrix Inversion}}
\newcommand\spechamiltonian[1]{#1\textit{-Matrix Eigenvalue}}
\newcommand\qca[1]{\ensuremath{#1}\textit{-Quantum Circuit Acceptance}}
\newcommand{\zero}{\ensuremath{0^{\otimes{k(n)}}}}

%%These duplicate BQSPACE definitions above!
\newcommand{\classfont}{\sf}
\newcommand{\Unitary}{\mathbf{U}}
\newcommand{\unitaryBQL}{{\classfont{BQ}_\Unitary\classfont{L}}}
\newcommand{\unitaryQMASPACE}{{\classfont{QMA}_\Unitary\classfont{SPACE}}}
\newcommand{\unitaryQSPACE}[3]{{\classfont{Q}_\Unitary\classfont{SPACE}}[#1](#2,#3)}
\newcommand{\unitaryBQSPACE}[1]{{\classfont{BQ}_\Unitary\classfont{SPACE}}[#1]}
%
%\newcommand{\eq}[1]{(\hyperref[eq:#1]{\ref*{eq:#1}})}
\newcommand\bigoh{\mathcal{O}}

\newcommand{\ee}{\mathcal{E}}
\newcommand{\ii}{\mathbb{I}}
\newcommand{\rl}{\rangle\langle}
\newcommand{\mg}{\mathcal{G}}
\newcommand{\hn}[1]{\|#1\|^H_{1\rightarrow 1}}
\newcommand{\ve}[1]{|#1\rangle\!\rangle}
\newcommand{\ro}[1]{\langle\!\langle#1|}
\newcommand{\bkett}[1]{|#1\rangle\!\rangle\langle\!\langle#1|}
%\newcommand{\ket}[1]{|#1\rangle}
%\newcommand{\bra}[1]{\langle#1|}
\newcommand{\bk}[1]{|#1\rangle\langle#1|}
\newcommand{\polylog}{\textrm{polylog}}

\newcommand{\tth}[0]{\textsuperscript{th}}
\newcommand{\st}[0]{\textsuperscript{st}}
\newcommand{\nd}[0]{\textsuperscript{nd}}
\newcommand{\rd}[0]{\textsuperscript{rd}}


\usepackage{xcolor}
\newcommand{\todo}[1]{{\color{red}{[{\bf TODO:}#1]}}}
\newcommand{\wf}[1]{{\color{violet}{[{\bf wf:}#1]}}}
\newcommand{\cl}[1]{{\color{purple}{[{\bf cl:}#1]}}}
\newcommand{\tocite}[1]{{\color{blue}{[{\bf CITE:}#1]}}}
\newcommand{\tocheck}[1]{{\color{red}{[{\bf TO CHECK:}#1]}}}

\DeclareMathAlphabet{\matheu}{U}{eus}{m}{n}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\id}{id}
\newcommand{\Favg}{\overline{F}}
\newcommand{\Paulis}{{\matheu P}}
\newcommand{\Clifs}{{\matheu C}}
\newcommand{\Hilb}{{\matheu H}}
\newcommand{\T}{{\matheu T}}
\newcommand{\sop}[1]{{\mathcal #1}}
\newcommand{\PL}[1]{{#1}^{P\!L}}
\newcommand{\BHn}{{{\mathcal B}({\mathcal H}^{\otimes n})}}
\newcommand{\I}{{\mathbb I}}
\newcommand{\CNOT}{{\mathrm{CNOT}}}
\newcommand{\plr}[1]{\hat{#1}} %pauli-liouville-represenation
\newcommand{\poly}{\textrm{poly}}

%\newcommand{\ket}[1]{|{#1}\rangle}
%\newcommand{\bra}[1]{\langle{#1}|}
\newcommand{\braket}[2]{\langle{#1}|{#2}\rangle}
\newcommand{\ketbra}[2]{|{#1}\rangle\!\langle{#2}|}
\newcommand{\kket}[1]{|{#1}\rangle\!\rangle}
\newcommand{\bbra}[1]{\langle\!\langle{#1}|}
\newcommand{\bbrakket}[2]{\langle\!\langle{#1}|{#2}\rangle\!\rangle}

\newcommand{\no}{\nonumber\\}
\newcommand{\even}{_\textrm{even}}
\newcommand{\odd}{_\textrm{odd}}

\newcommand{\ns}{{\textsc{ns}}}
\newcommand{\ceil}[1]{\left\lceil{#1}\right\rceil}
\newcommand{\se}{\succcurlyeq}
\newcommand{\di}{\textrm{diag}}
\newcommand{\orcl}{{\pmb{\sop O}}}
\newcommand{\SA}{{\mathbf{S}_X^n}}
\newcommand{\SB}{{\mathbf{S}_Y^n}}
\newcommand{\Si}{{\mathbf{S}_1}}
\newcommand{\Sj}{{\mathbf{S}_2}}
\newcommand{\SU}{S_U}
\newcommand{\Ugroup}[1]{\mathbf{U}^{#1}}
\usepackage{mathtools}
\newcommand{\pc}{preimage-correct}
\newcommand{\rpc}{randomized-preimage-correct}
\newcommand{\spi}{\pmb{\sigma}_{\textrm{pre}}}
\newcommand{\sperm}{S_{\textrm{pre}}}
\newcommand{\Swit}{\mathbf{S}_{i,\textrm{wit}}}
\newcommand{\Sprime}{\mathbf{S}''}
\newcommand{\porcl}{{\pmb{\sop P}}}


%-----------------------------------------------------------------------------%



\begin{document}


%+Title
\begin{titlepage}
\title{A Complete Characterization of Unitary Quantum Space}
%\author{Bill Fefferman\thanks{Joint Center for Quantum Information and Computer Science (QuICS), University of Maryland, wjf@umd.edu} \and Cedric Yen-Yu Lin\thanks{QuICS, University of Maryland, cedricl@umiacs.umd.edu}}
\author[1]{Bill Fefferman\thanks{wjf@umd.edu}}
\author[1]{Cedric Yen-Yu Lin\thanks{cedricl@umiacs.umd.edu}}
\affil[1]{Joint Center for Quantum Information and Computer Science (QuICS), University of Maryland}
\date{\today}
%\date{}
\maketitle
%\medskip
\begin{abstract}
We give two complete characterizations of unitary quantum space-bounded classes.  The first is based on the Matrix Inversion problem for well-conditioned matrices.  We show that given the size-$n$ efficient encoding of a $2^{\mathcal{O}(k(n))} \times 2^{\mathcal{O}(k(n))}$ well-conditioned matrix $H$, approximating a particular entry of $H^{-1}$ is complete for the class of problems solvable by a quantum algorithm that uses $\mathcal{O}(k(n))$ space and performs all quantum measurements at the end of the computation. In particular, the problem of computing entries of $H^{-1}$ for an explicit well-conditioned $n \times n$ matrix $H$ is complete for unitary quantum logspace.

We then show that the problem of approximating to high precision the least eigenvalue of a positive semidefinite matrix $H$, encoded as a circuit, gives a second characterization of unitary quantum space complexity. In the process we also establish an equivalence between unitary quantum space-bounded classes and certain $\QMA$ proof systems. As a consequence, we establish that $\QMA$ with exponentially small completeness-soundness gap is equal to $\PSPACE$, that determining whether a local Hamiltonian is frustration-free is $\PSPACE$-complete, and give a provable setting in which the ability to prepare $PEPS$ states gives less computational power than the ability to prepare the ground state of a generic local Hamiltonian.
\end{abstract}
\thispagestyle{empty}
\end{titlepage}
\clearpage
\setcounter{page}{1}
\section{Introduction}
In this work we will study unitary quantum space-bounded classes - those problems solvable using a given amount of (quantum and classical) space, with all quantum measurements performed at the end of the computation. We give two sets of complete problems for these classes; to the best of our knowledge, these are the first natural complete problems proposed for quantum space-bounded classes. Both complete problems will turn out to have many implications on the power of space-bounded quantum computation.

In the following discussion, $\unitaryBQSPACE{k(n)}$ refers to the class of problems solvable with bounded error by a quantum algorithm running in $\mathcal{O}(k(n))$; the subscript $\Unitary$ indicates that the algorithm is unitary, i.e. employs no intermediate measurements.
\subsection{Inverting well-conditioned matrices}
Matrix Inversion is one of the most important and ubiquitous computational problems.  The problem of inverting integer matrices is complete for $\DET$, the class of functions reducible in $\Logspace$ (i.e., in deterministic space $\bigoh(\log{n})$) to computing the determinant of an integer matrix, which is contained in deterministic $\bigoh(\log^2{n})$ space \cite{berkowitz, cook}.  It has long been a major question in computational complexity to understand if Integer Matrix Inversion is in $\Logspace$, which would imply that $\Logspace=\sf{NL}=\DET$.

Recently, Ta-Shma, building on work of Harrow, Hassidim, and Lloyd, showed that inverting a well-conditioned $n \times n$ matrix can be approximated by a quantum algorithm using $O(\log n)$ space, but with intermediate measurements \cite{tashma,HHL}. This gives a quadratic advantage in space over the best known classical algorithms, which require $\Omega(\log^2n)$ space.

We first consider a generalization of Ta-Shma's well-conditioned matrix inversion problem \cite{tashma}:\begin{definition}[\matrixinvert{k(n)}] \label{def: matrix invert}
Given as input is the size-$n$ efficient encoding of a $2^{k(n)} \times 2^{k(n)}$ positive semidefinite matrix $H$ with a known upper bound $\kappa = 2^{\mathcal{O}(k(n))}$ on the condition number, so that $\kappa^{-1}I\preceq H \preceq I$, and $s,t\in \lbrace 0,1\rbrace^{k(n)}$. It is promised that either $|H^{-1}(s,t)|\geq b$
 or $|H^{-1}(s,t)|\leq a$ for some constants $0 \le a < b \le 1$; determine which is the case.
 \end{definition}
For a definition of efficient encoding, see Definition \ref{def: efficient encoding}. As a consequence of our definition, the matrix will have at most $\poly(n)$ nonzero entries in each row.
%Here by a size-$n$ efficient encoding, we mean a classical procedure (e.g. Turing machine) specified using $n$ bits, that on input $i \in \{0,1\}^{k(n)}$ outputs the locations and contents of the non-zero entries of the $i$-th row, using at most $\poly(n)$ time and $\bigoh(k(n))$ workspace. As a consequence there are at most $\poly(n)$ nonzero entries in each row.
%\footnote{We note that for any explicit $m \times m$ matrix it is not difficult to construct a circuit encoding of size $n = \poly(m)$ that runs in $\bigoh(k(n)) = \bigoh(\log(n))$ space. Hence the requirement that there exists a circuit encoding is vacuous for $k(n) = \bigoh(\log(n))$.} 
We show the following:
\begin{theorem} \label{thm: matrix invert}
For $\Omega(\log(n)) \le k(n) \le 2^{\poly(n)}$, \matrixinvert{\mathcal{O}(k(n))} is complete for $\unitaryBQSPACE{\mathcal{O}(k(n))}$ under classical reductions using $\poly(n)$ time and $\mathcal{O}(k(n))$ space.
\end{theorem}

Here the subscript $\Unitary$ means that our quantum computation is unitary: there are no intermediate measurements. We also note that our algorithm (Theorem \ref{thm: matrix inversion alg}) actually approximates the matrix entry $|H^{-1}(s,t)|$ to precision $2^{-\mathcal{O}(k)}$. In particular, if we take $k = \bigoh(\log n)$ we get the following:
\begin{corollary}
The problem of approximating, to $1/\poly(n)$ precision, an entry of the inverse of a PSD $n \times n$ matrix with condition number at most $\poly(n)$ is $\unitaryBQL$-complete under $\Logspace$-reductions.
\end{corollary}

This result improves upon Ta-Shma's result \cite{tashma} in two ways. First, unlike Ta-Shma's algorithm, our algorithm does not use intermediate measurements.  Although the ``safe storage'' principle of quantum time-bounded computation tells us that quantum measurements can be deferred, an equivalent principle is not known for space complexity.  The standard procedure for deferring measurements in time-bounded computation may incur an exponential blow-up in space.  

In addition, we show that the problem of inverting well-conditioned matrices is hard for unitary quantum logspace under $\Logspace$-reductions. In other words, one cannot show that well-conditioned matrices are invertible in $\Logspace$ unless one also shows that $\Logspace=\unitaryBQL$, which seems quite unlikely.

Furthermore, since it is straightforward to see that Well-conditioned Matrix Inversion reduces to Integer Matrix Inversion, we can use our result to obtain a direct proof that $\unitaryBQL\subseteq\DET$, which was previously known indirectly via the containments $\unitaryBQL\subseteq\PLclass\subseteq\DET$ \cite{Watrous03,Borodin84}.

%\cl{Maybe add a discussion on matchgates and determinants.}
%When $k(n)=\bigoh(\log{n})$ this result has an interesting interpretation: one cannot show that well-conditioned matrices are invertible in solvable in classical $\Logspace$ unless one also shows that classical $\Logspace$ equals unitary quantum $\Logspace$, which seems quite unlikely.
\subsection{Matrix Eigenvalue problem} 
Our second result completely characterizes quantum space complexity via the following problem:
\begin{definition}[$\spechamiltonian{k(n)}$ problem] \label{def: spechamiltonian}
Given as input is the size-$n$ efficient encoding of a positive semidefinite matrix $H$, such that the maximum entry in absolute value $\|H\|_{max}$ is upper bounded by a constant. Let $\lambda_{min}$ be the minimum eigenvalue of $H$. It is promised that either $\lambda_{min} \le a$ or $\lambda_{min} \ge b$, where $a$ and $b$ are some real numbers such that $b-a > 2^{-\mathcal{O}(k(n))}$. Output 1 if $\lambda_{min} \le a$, and output 0 otherwise.
\end{definition}

\begin{theorem} \label{thm: spechamiltonian}
For $\Omega(\log(n)) \le k(n) \le 2^{\poly(n)}$, $\spechamiltonian{\mathcal{O}(k(n))}$ is complete for \\ $\unitaryBQSPACE{\mathcal{O}(k(n))}$ under classical reductions using $\poly(n)$ time and $\mathcal{O}(k(n))$ space.
\end{theorem}

In the process, we also show the following equivalence between unitary quantum space-bounded computation and $\QMA$-proof systems:
\begin{theorem}
$\unitaryBQSPACE{\mathcal{O}(k(n))}$ is equivalent to the class of problems characterized by having quantum Merlin Arthur proof systems running in polynomial time, $\mathcal{O}(k(n))$ witness size and space, and $2^{-\mathcal{O}(k(n))}$ completeness-soundness gap.
\end{theorem}

This second characterization has several interesting consequences.  In particular, if we take $k = \poly(n)$ we see that $\QMAexp$, the variant of $\QMA$ with exponentially small completeness-soundness gap, is exactly equal to $\BQPSPACE=\PSPACE$.  

The closest classical counterpart of $\QMAexp$ is $\NP^{\PP}$: given a classical witness, the verifier runs a classical computation that in the YES case accepts with probability at least $c$, or in the NO case accepts with probability at most $s$, where $c>s$. Note that in the classical case $c - s > \exp(\poly)$ is automatically satisfied. Since $\NP^{\PP}$ is in the counting hierarchy, the entirety of which is contained in $\PSPACE$ (see e.g., \cite{allenderwagner}), we see that the quantum proof protocol is strictly stronger than the classical one, unless the counting hierarchy collapses to the second level.

We also show that the \emph{local} Hamiltonian problem is $\PSPACE$-complete when the promise gap is only exponentially small (for details see Appendix \ref{app:localhamiltonian}). This is in contrast to the usual case when the gap is polynomially small, where the problem is $\QMA$-complete. Perhaps more surprisingly, $\QMAexp = \PSPACE$ is more powerful than $\PostBQP=\PP$, the class of problems solvable with postselected quantum computation \cite{aaronson05}.

Another consequence concerns Projected Entangled Pair States, or PEPS, a natural extension of matrix product states to two and higher dimensions, which can be described as the ground state of certain frustration-free local Hamiltonians \cite{vc04}. A characterization of the computational power of PEPS was given in \cite{swv07}, and can be summarized as follows: let $O_{PEPS}$ be a quantum oracle that, given the description of a PEPS, outputs the PEPS (so the output is quantum). Then $\BQP^{O_{PEPS}}_{\parallel,\text{classical}} = \PostBQP = \PP$, where (following Aaronson \cite{aaronson05}) the subscript  denotes that only classical nonadaptive queries to the oracle are allowed. Moreover, let $\PQP$ stand for the set of problems solvable by a quantum computer with \emph{unbounded error}; then it can be straightforwardly shown that $\PQP^{O_{PEPS}}_{\parallel,\text{classical}} = \PP$ as well (see Appendix \ref{app:peps}).

On the other hand, suppose we have an oracle $O_{LH}$ that given the description of a local Hamiltonian, outputs a ground state of the Hamiltonian. Then our results show that $\QMAexp = \PSPACE \subseteq \PQP^{O_{LH}}_{\parallel,\text{classical}}$. This shows that in the setting of unbounded-error quantum computation, PEPS do not capture the full computational complexity of general local Hamiltonian ground states unless $\PP=\PSPACE$. We leave open the problem of determining the complexity of $\BQP^{O_{LH}}_{\parallel,\text{classical}}$.

Lastly, we are able to strengthen our characterization to show that $\QMAexp$ contains $\PSPACE$ (see Appendix \ref{app:perfectcompleteness}), even when restricted to having perfect completeness.  This allows us to prove that testing if a local Hamiltonian is frustration-free is a $\PSPACE$-complete problem.  
 \section{Preliminaries}
\subsection{Quantum circuits}
We will assume a working knowledge of quantum information. For an introduction, see \cite{nc00}.

A \emph{quantum circuit} consists of a series of quantum gates each of which come from some universal gateset, such as the gateset consisting of Hadamard and Toffoli gates \cite{shi}.  A \emph{description} of the quantum circuit is a string consisting of the gates in the circuit, together with the qubits that each gate acts on.
 For functions $f,g:\mathbb{N}\rightarrow\mathbb{N}$, we say a family of quantum circuits $\{Q_x\}_{x\in\{0,1\}^*}$ is \emph{$f$-time $g$-space uniformly generated} if there exists a deterministic classical Turing machine that on input $x\in\{0,1\}^n$ and $i>0$ outputs the $i$-th gate of $Q_x$ within time $f(n)$ and space $g(n)$ \cite{nc00}.  
 
Our restriction to a specific gateset is without loss of generality, even for logarithmic space algorithms:  there exists a deterministic algorithm that given any unitary quantum gate $U$ and a parameter $\epsilon$, outputs a sequence of at most $\polylog({1/\epsilon})$ gates from any universal quantum gateset that approximates $U$ to precision $\epsilon$ in space $\bigoh({\log({1/\epsilon})})$ and time $\polylog({1/\epsilon})$ \cite{mw12}.  This improves the Solovay-Kitaev theorem, which guarantees a space bound of $\polylog(n)$; see e.g., \cite{nc00}.
 %\begin{theorem}[\cite{mw12}]  For every universal set $S$ of unitary gates that is closed under adjoint, every language solvable by a bounded-error quantum %
\subsection{Space-bounded computation} \label{sec: space bounded computation}
For our model of unitary quantum space-bounded computation, we will consider a quantum system with purely classical control, because there are no intermediate quantum measurements to condition future operations on. Specifically, we use the following definition (see Appendix \ref{app: space bounded} for more details):

\begin{definition} \label{def: qspace}
A promise problem $L=(L_{YES},L_{NO})$ is in $\QSPACE[k(n)](c,s)$ if there exists a $\poly(|x|)$-time $\mathcal{O}(k)$-space uniformly generated family of quantum circuits $\{Q_x\}_{x\in\{0,1\}^*}$, where each circuit $Q_x=U_{x,T}U_{x,T-1}\cdots U_{x,1}$ has $T=2^{\mathcal{O}(k)}$ gates, and acts on $\mathcal{O}(k(|x|))$ qubits, such that:\\
 If $x \in L_{yes}$:
\begin{equation}
\bra{0^k} Q^\dagger_x \ket{1}\bra{1}_{out} Q_x \ket{0^k} \ge c.
\end{equation}
Whereas if $x \in L_{no}$:
\begin{equation}
\bra{0^k} Q^\dagger_x \ket{1}\bra{1}_{out} Q_x \ket{0^k} \le s.
\end{equation}
Here $out$ denotes a single qubit we measure at the end of the computation; no intermediate measurements are allowed.  
Furthermore, we require $c$ and $s$ to be computable in classical $\bigoh(k(n))$-space.
%For the purposes of this work, we will demand that the space bound $k(n)$ is at least $\bigoh(\log{n})$ and no more than $2^{\poly(n)}$.  
\end{definition}

The bound $T=2^{\mathcal{O}(k)}$ on the circuit size comes from that any classical Turing machine generating $Q_x$ using space $\bigoh(k(|x|))$ has at most $2^{\mathcal{O}(k)}$ configurations. We note that $2^{\mathcal{O}(k)}$ gates suffice to approximate any gate on $\bigoh(k)$ qubits to high accuracy (see e.g. \cite[Chapter~4]{nc00}). The $\poly(|x|)$ time bound on the classical control can be assumed WLOG; see Appendix \ref{app: space bounded} for details.

\begin{definition} $\BQSPACE[k]=\QSPACE[k](2/3,1/3)$.\end{definition}
%\begin{definition}$\PQSPACE[k]=\QSPACE[k](1/2,1/2)$.\end{definition}
\begin{theorem}[Watrous \cite{Watrous99}]\label{thm:pqpspace} $\BQSPACE[poly]=\PSPACE$.
\end{theorem}

We now define space- and time-bounded analogues of $\QMA$:
\begin{definition}We say a promise problem $L=(L_{yes},L_{no})$ is in $\bddQMA{t}{k}{m}{c}{s}$ if there exists a $t$ time and $(k+m)$ space uniformly generated family of quantum circuits $\{ V_x\}_{x\in\{0,1\}^*}$, each of size at most $t(|x|)$, acting on $k(|x|)+m(|x|)$ qubits, so that:\\

If $x \in L_{yes}$ there exists an $m$-qubit state $\ket{\psi}$ such that:
\begin{equation}
\left(\bra{\psi}\otimes \bra{0^k}\right) V^\dagger_x \ket{1}\bra{1}_{out} V_x \left(\ket{\psi}\otimes \ket{0^k}\right) \ge c.
\end{equation}
Whereas if $x \in L_{no}$, for all $m$-qubit states $\ket{\psi}$ we have:
\begin{equation}
\left(\bra{\psi}\otimes \bra{0^k}\right) V^\dagger_x \ket{1}\bra{1}_{out} V_x \left(\ket{\psi}\otimes \ket{0^k}\right) \le s.
\end{equation}
$out$ denotes a single qubit measured at the end of the computation; no intermediate measurements are allowed.  
Here $c$ and $s$ are computable in classical $\bigoh(t(n))$-time and $\bigoh(k(n)+m(n))$-space.
  \end{definition}

\begin{definition} $\QMA=\bddQMA{\poly}{\poly}{\poly}{2/3}{1/3}$.
\end{definition}
\begin{definition} $\QMAexp=\bigcup_{c \in (0,1]}\bddQMA{\poly}{\poly}{\poly}{c}{c-2^{-\poly}}$.
\end{definition}

\subsection{Other definitions and results}
We use the following definition of \emph{efficient encodings} of matrices:
\begin{definition}\label{def: efficient encoding}Let $M$ be a $2^{k} \times 2^{k}$ matrix, and $\mathcal{A}$ be a classical algorithm (e.g. a Turing machine) specified using $n$ bits. We say that $\mathcal{A}$ is an \emph{efficient encoding} of $M$ if on input $i\in\{0,1\}^k$, $\mathcal{A}$ outputs the non-zero entries of the $i$-th row, using at most $\poly(n)$ time and $\bigoh(k)$ workspace (not including the output size). Note that as a consequence $M$ has at most $\poly(n)$ nonzero entries in each row.
\end{definition}
Frequently in this paper we will specify a matrix $M$ in the input by giving an efficient encoding of $M$. The size of the encoding is then the input size, which we will usually indicate by $n$.

Finally, we will frequently be assuming the existence of  algorithms that compute some common functions on $n$-bit numbers, such as $\sin,\cos,\arcsin,\arccos$ and exponentiation, to within $1/\poly(n)$ accuracy in classical $\bigoh (\log{n})$ space.  Algorithms for these tasks have been designed by Reif \cite{reif}. We will use these algorithms implicitly for the rest of the paper\footnote{Reif's algorithms actually take only $\bigoh (\log\log{n}\log\log\log{n})$ space, but for simplicity we only use the $\bigoh (\log{n})$ upper bound.}.

%%Bill's note: End of preliminary section
\section{Characterization 1: Matrix Inversion}
This section is devoted to showing Theorem \ref{thm: matrix invert}, which gives a characterization of $\unitaryBQSPACE{k(n)}$ via the complete problem $\matrixinvert{k(n)}$ (recall Definition \ref{def: matrix invert}). %We first give a space-bounded algorithm for $\matrixinvert{k(n)}$ in Section \ref{sec: matrix inversion alg}, and then demonstrate hardness in Section \ref{sec: matrix inversion hard}.
\subsection{$\matrixinvert{k(n)}$ is in $\unitaryBQSPACE{k(n)}$} \label{sec: matrix inversion alg}
\begin{theorem} \label{thm: matrix inversion alg}
Fix functions $k(n)$, $\kappa(n)$, and $\epsilon(n)$. Suppose we are given the size-$n$ efficient encoding of a $2^{k(n)} \times 2^{k(n)}$ PSD matrix $H$ such that $\kappa^{-1} I \preceq H \preceq I$. We are also given $\poly(n)$-time $\mathcal{O}(k+\log(\kappa/\epsilon))$-space uniform quantum circuits $U_a$ and $U_b$ acting on $k$ qubits. Let $U_a\ket{0}^{\otimes k(n)} = \ket{a}$ and $U_b\ket{0}^{\otimes k(n)} = \ket{b}$. The following tasks can be performed with $\poly(n)$-time $O(k+\log(\kappa/\epsilon))$-space uniform quantum circuits over $\bigoh (k+\log(\kappa/\epsilon))$ qubits:
\begin{compactenum}
\item With at least constant probability, output an approximation of the quantum state $H^{-1}\ket{b} / \|H^{-1}\ket{b}\|$ up to error $\epsilon$.
\item Estimate $\|H^{-1}\ket{b}\|$ up to precision $\epsilon$.
\item Estimate  $|\bra{a}H^{-1}\ket{b}|$ up to precision $\epsilon$.
\end{compactenum}
These circuits do not require intermediate measurements.
\end{theorem}
Note that if intermediate measurements were allowed instead, then in the case $k = \mathcal{O}(\log n)$ this result is already proven by Ta-Shma \cite[Theorem~6.3]{tashma} (and generalizes to other space bounds without much difficulty). We strengthen Ta-Shma's result by showing that intermediate measurements are not necessary. By taking $\kappa = 2^{\bigoh (k)}$ and $\epsilon = 2^{-\bigoh (k)}$ to be constant, we get: 

\begin{corollary}
$\matrixinvert{k(n)} \in \unitaryBQSPACE{k(n)}$.
\end{corollary}
In fact our algorithm is much stronger: to solve $\matrixinvert{k(n)}$ we merely need to approximate $|\bra{s}H^{-1}\ket{t}|$ to constant precision, while Theorem \ref{thm: matrix inversion alg} actually gives an approximation to precision $2^{-\bigoh (k)}$ in $\bigoh (k(n))$ unitary quantum space. Moreover our algorithm does not require $s$ and $t$ to be computational basis states.

We note that we can modify our definition of unitary quantum space-bounded classes to include computing functions, for instance by adding a write-only one-way output tape of qubits to the Turing machine (see the discussion in Appendix \ref{app: space bounded}), that are all measured at the very end of the computation. The error reduction result (Corollary \ref{obvious2}) later in our work allows the total error can be reasonably controlled. With such a modification we can compute the whole matrix inverse in unitary quantum logspace. We will not pursue this modified model further in this work.
%\wf{We should also point out that our result scales for non-logarithmic space bounds, where Ta-Shma's does not}

To prove Theorem \ref{thm: matrix inversion alg}, we first start out with the following lemma:
\begin{lemma}[Ta-Shma \cite{tashma}] \label{lem: matrix inversion lemma}
There is a $\bigoh (k + \log(\kappa/\epsilon'))$-space uniform quantum unitary transformation $W_H$ over $k+\ell = \bigoh (k+ \log(\kappa/\epsilon'))$ qubits, such that for any $k$-qubit input state $\ket{b}$,
\begin{equation}
W_H (\ket{0}^{\otimes \ell} \otimes \ket{b}) = \alpha \ket{0}_{out} \otimes \ket{\psi_b} + \sqrt{1-\alpha^2} \ket{1}_{out} \otimes\ket{\psi'_b},
\end{equation}
where $\ket{\psi_b}$ and $\ket{\psi'_b}$ are normalized states such that $\| \ket{\psi_b} - \ket{0}^{\otimes \ell-1} \otimes \frac{H^{-1}\ket{b}} {\|H^{-1}\ket{b}\|} \| \le \epsilon'$, $\alpha$ is a positive number satisfying $|\alpha - \frac{\|H^{-1}\ket{b}\|}{\kappa}| \le \epsilon'$, and ``out'' is a 1-qubit register.
\end{lemma}
The proof of this lemma is essentially contained in the proof of \cite[Theorem~6.3]{tashma}, or can be obtained by combining \cite[Theorem~4.1]{tashma} with the analysis of Harrow, Hassidim and Lloyd \cite{HHL}. The essential idea of the proof is to use phase estimation on $\exp(iA)$ to compute the eigenvalues $\lambda$ of the matrix $H$ into an auxilliary register; implement the unitary transformation $\ket{\lambda}\ket{0} \rightarrow \ket{\lambda}[(\kappa\lambda)^{-1}\ket{0}+(\sqrt{1-(\kappa\lambda)^{-2}}\ket{1}]$; and finally uncompute the eigenvalues $\lambda$. Ta-Shma showed how to implement $\exp(iH)$ in $\bigoh (k+\log(1/\epsilon))$ space \cite[Theorem~4.1]{tashma} (their proof works for general matrices with efficient encodings); alternatively the more recent sparse Hamiltonian simulation algorithms by Berry et al. (Theorem \ref{thm:ham_sim}) has the same space requirement and is more time efficient.


The proof idea for Theorem \ref{thm: matrix inversion alg} is to use amplitude amplification to obtain the state $\ket{0}_{out} \otimes \ket{\psi_b}$, and also generating an estimate for $\alpha \approx \|H^{-1}\ket{b}\|$. (This idea is already present in the work of Nagaj et al. for QMA gap amplification \cite{nwz11}, or the Oblivious Amplitude Amplification technique in \cite{berry14,bccks15,berry15}.) Specifically, consider the two projectors:
\begin{equation}
\Pi_0 = \ket{0}\bra{0}_{anc} \otimes \ket{b}\bra{b}, \quad \Pi_1 = W_H^\dagger (\ket{0}\bra{0}_{out} \otimes I) W_H.
\end{equation}
$\Pi_0$ projects onto the initial subspace, while $\Pi_1$ projects onto the initial states that would be accepted by the final measurement. By an argument similar to Grover's algorithm, if we implement the rotation $R=-(I-2\Pi_0)(I-2\Pi_1)$ $\bigoh (1/\alpha)$ times we will generate an output state with constant overlap with $\ket{0}_{out} \otimes \ket{\psi_b}$. $\alpha$ can be estimated by performing phase estimation on the operator $R$.

The above argument shows how to do the first and second tasks listed in Theorem \ref{thm: matrix inversion alg}. For the third task (approximating $|\bra{a}H^{-1}\ket{b}|$), we can choose $\Pi'_1 = W_H^\dagger (\ket{0}\bra{0}_{out} \otimes I) (I_{anc} \otimes \ket{a}\bra{a})(\ket{0}\bra{0}_{out} \otimes I) W_H$ instead, and phase estimation on $R=-(I-2\Pi_0)(I-2\Pi'_1)$ will give an estimate for $|\bra{a}H^{-1}\ket{b}|$. For the full proof, see Appendix \ref{app: matrix inversion alg}.

\subsection{$\matrixinvert{k(n)}$ is hard for $\unitaryBQSPACE{k(n)}$} \label{sec: matrix inversion hard}
We start from the following simple hard problem for $\unitaryBQSPACE{k(n)}$:
\begin{definition}[\qca{k(n)}]
	Given as input is the encoding of a $\poly(n)$-time $k(n)$-space uniform quantum circuit $Q$ acting on $k(n)$ qubits with $T = 2^{\mathcal{O}(k(n))}$ 1- or 2-qubit gates.  It is promised that either the matrix entry $|\langle {\zero}|Q|{\zero}\rangle| \geq 2/3$ or $|\langle {\zero}|Q|{\zero}\rangle| \leq 1/3$; determine which is the case.
\end{definition}
\begin{lemma} \label{lem: quantum circuit acceptance}
	$\qca{k(n)}$ is $\unitaryBQSPACE{k(n)}$-hard under classical polynomial time, $k(n)$ space reductions.
\end{lemma}
\begin{proof}This lemma is implicit in e.g., \cite{bbbv,dawsonnielsen}.  We give a proof in Appendix \ref{app:qca} for completeness.
\end{proof}
\begin{theorem}
$\matrixinvert{k(n)}$ is $\unitaryBQSPACE{k(n)}$-hard under classical reductions computable in polynomial time and $\bigoh (k)$ space.
\end{theorem}
\begin{proof}
Our proof proceeds as in \cite{HHL}.  We will show that $\matrixinvert{k(n)}$ is as hard as $\qca{k(n)}$.  Given an instance of the latter, i.e., a circuit on $k(n)$ qubits, $Q=U_TU_{T-1}\cdots U_1$ with $T = 2^{\mathcal{O}(k(n))}$, define the following unitary of dimension $3T2^k$:
\[U=\sum_{t=1}^{T}|t+1\rangle\langle t|\otimes U_t+|t+T+1\rangle\langle t+T|\otimes I+|t+2T+1\bmod{3T}\rangle\langle t+2T|\otimes U_{3T+1-t}^{\dagger}\]	
Crucially, note that for any $t$ in the range $[T+1,2T]$ and any state $|\psi\rangle$ on $k(n)$ qubits: 
\begin{equation}\label{eqn:fullclock}
	U^t|1\rangle|\psi\rangle=|t+1\rangle\otimes Q|\psi\rangle
\end{equation}
Furthermore $U^{3T}=I$, a fact we will soon exploit. We now construct the Hermitian matrix:
\begin{equation}
H=\begin{bmatrix}
    0 & I-Ue^{-1/T}\\
   I-U^{\dagger}e^{-1/T} &  0
\end{bmatrix}
\end{equation}
 $H$ has dimension $N=6Tn$ and condition number $\kappa\leq 2T=2^{\bigoh (k)}$.  Notice that given as input a description of $Q$ we can compute each entry of $A$ to within $2^{-\mathcal{O}(k(n))}$ error in $\mathcal{O}(k(n))$ space, via space efficient algorithms for exponentiation \cite{reif}.
   Furthermore, $H^{-1}$ is the following matrix:
\begin{equation}
\begin{bmatrix}
    0 & \left(I-U^\dagger e^{-1/T}\right)^{-1}\\
   \left(I-Ue^{-1/T}\right)^{-1} &  0
\end{bmatrix}
\end{equation}
$\left(I-Ue^{-1/T}\right)^{-1}$ is just the power series $\sum_{j=0}^\infty U^j e^{-j/T}=\frac{1}{1-e^{-3}}\sum_{j=0}^{3T-1} U^{j} e^{-j/T}$, where we've used $U^{3T}=1$. Therefore for any fixed $t \in [0,3T-1]$,
 \begin{align}
\langle\zero|\langle t+1|\left(I-Ue^{-1/T}\right)^{-1}|1\rangle|\zero\rangle
%&=\langle\zero|\langle t+1|\left(\sum_{j=0}^\infty U^j e^{-j/T}\right)|1\rangle|\zero\rangle \\
%&= \left( \sum_{x=0}^\infty e^{-3jT/T} \right) 
&= \frac{1}{1-e^{-3}}\langle\zero|\langle t+1|\left(\sum_{j'=0}^{3T-1} U^{j'} e^{-j'/T}\right)|1\rangle|\zero\rangle
\end{align}
which is a particular entry in $H^{-1}$. In the second line we've used $j = 3Tx + j'$ for some integers $x$ and $j' \in [0,3T-1]$, and used that $U^{3T}=I$.  For any $t \in [T+1,2T]$, as a consequence of Equation \ref{eqn:fullclock} the above quantity equals
\begin{equation}
\frac{e^{-t/T}}{1-e^{-3}}\langle\zero|Q|\zero\rangle.
\end{equation}
In particular, an estimation of this entry of $H^{-1}$ will solve \qca{k(n)}.
\end{proof}

%%Bill's Note: End of Matrix Inversion section
\section{Characterization 2: The $\spechamiltonian{k(n)}$ Problem}
%We will now show an alternate characterization of unitary quantum space via another complete problem for $\unitaryBQSPACE{k(n)}$, for any function $k(n)$ at least $\Omega(\log n)$ and at most $\exp(\bigoh (n))$. Here completeness is defined under a reduction computable by a \emph{classical} algorithm in polynomial time and $\mathcal{O}(k(n))$ space.
%\begin{definition}[$\spechamiltonian{k(n)}$ problem]
%Given as input is the size-$n$ efficient encoding of a $2^{\mathcal{O}(k(n))} \times 2^{\mathcal{O}(k(n))}$ positive semidefinite matrix $H$, such that the maximum entry in absolute value $\|H\|_{max}$ is upper bounded by a constant. Let $\lambda_{min}$ be the minimum eigenvalue of $H$. It is promised that either $\lambda_{min} \le a$ or $\lambda_{min} \ge b$, where $a$ and $b$ are some real numbers such that $b-a > 2^{-\mathcal{O}(k(n))}$. Output 1 if $\lambda_{min} \le a$, and output 0 otherwise.
%\end{definition}
We will now prove Theorem \ref{thm: spechamiltonian}; this gives an alternate characterization of unitary quantum space via the complete problem $\spechamiltonian{k(n)}$ (see Definition \ref{def: spechamiltonian}). In the process we will show an equivalence with a suitably defined $\QMA$ protocol.
%\subsection{$\spechamiltonian{k(n)}$ is in $\unitaryBQSPACE{k(n)}$}
%We show the main result of this section by proving first, in Section \ref{subsec:specham-in-bddqma}, that $\spechamiltonian{k(n)}$ is in $k(n)$-Space-bounded $\QMAexp$ and then in Section \ref{subsec:bddqma-in-bqspace} that $k(n)$-Space-bounded $\QMAexp$ is in $\unitaryBQSPACE{k(n)}$.
\subsection{A $\QMA$ proof system for $\spechamiltonian{k(n)}$}\label{subsec:specham-in-bddqma}
This section will be devoted to showing the following result:
\begin{theorem} \label{lem:qma protocol}
$\spechamiltonian{k(n)}$ is contained in $\bddQMA{\poly}{\Theta(k(n))}{\Theta(k(n))}{c}{s}$ for some $c,s$ such that $c - s > 2^{-\mathcal{O}(k(n))}$.
\end{theorem}
Our strategy is to simulate the operator $e^{-iHt}$, and then use a stripped-down version of phase estimation to estimate an eigenvalue of $H$. For sparse Hamiltonian simulation we use the following:
\begin{theorem}[\cite{berry14,bccks15,berry15}] \label{thm:ham_sim}
Given as input is the size-$n$ efficient encoding of a $2^{k(n)} \times 2^{k(n)}$ Hermitian matrix $H$. Then treated as a Hamiltonian, the time evolution $\exp(-iHt)$ can be simulated using $\text{\emph{poly}}(n,k,\|H\|_{max}, t, \log(1/\epsilon))$ operations and $\bigoh(k+\log(t/\epsilon))$ space.
\end{theorem}
While the space complexity was not explicitly stated in \cite{berry14,bccks15,berry15}, it can be seen from the analysis (see e.g. \cite{bccks15}). The crucial thing to notice in Theorem \ref{thm:ham_sim} is the polylogarithmic scaling in the error $\epsilon$; this implies that we can obtain polynomial precision in $\exp(-iHt)$ using only polynomially many operations. Also note that the maximum eigenvalue of $H$, $\|H\|$, satisfies $\|H\| \le \poly(n) \|H\|_{max}$.
%\begin{remark}
%Suppose a matrix $H$ has at most $n$ nonzero entries per row, each of which is no more than $\|H\|_{max}$ in absolute value. Then $\| H \| \le n\|H\|_{max}$.
%\end{remark}
\begin{proof}[Proof of Theorem \ref{lem:qma protocol}]
We are given the size-$n$ efficient encoding of a $2^{k(n)} \times 2^{k(n)}$ PSD matrix $H$, and it is promised that the smallest eigenvalue $\lambda_{min}$ of $H$ is either  at most $a$ or at least $b$. Merlin would like to convince us that $\lambda_{min} \le a$; he will send us a purported $k$-qubit eigenstate $\ket{\psi}$ of $H$ with eigenvalue $\lambda_{min}$. Choose $t = \pi / (\poly(n)\|H\|_{max}) \le \pi / \|H\|$; then all eigenvalues of $Ht$ lie in the range $[0,\pi]$, and the output of phase estimation on $\exp(-iHt)$ will be unambiguous. We preform, on $\psi$, phase estimation of $\exp(-iHt)$ with one bit of precision:
\begin{align} \label{circ: poor man phase estimation}
&\Qcircuit @C=1em @R=.7em {
\lstick{\ket{0}}& \gate{H} & \ctrl{1} & \gate{H} & \rstick{\frac{1+e^{-i\lambda t}}{2}\ket{0} +\frac{1-e^{-i\lambda t}}{2}\ket{1} } \qw \\
\lstick{\ket{\psi}}& \qw & \gate{e^{-iHt}}  & \qw & \rstick{\ket{\psi}} \qw
}
\end{align}
Theorem \ref{thm:ham_sim} gives an implementation of $\exp(-iHt)$ up to error $\epsilon = 2^{-\Theta(k(n))}$ using $\poly(n)$ operations and $\bigoh(k(n))$ space.

In Circuit (\ref{circ: poor man phase estimation}) we've assumed $\ket{\psi}$ is an eigenstate of $H$ with eigenvalue $\lambda$. If we measure the control qubit at the end, the probability we obtain 0 is $(1+\cos(\lambda t))/2$. Therefore if $\psi$ is a eigenstate with eigenvalue at most $a$, we can verify this with probability at least $c=(1+\cos(at))/2 - \epsilon$, where $\epsilon$ is the error in the implementation of $\exp(-iHt)$. Otherwise if $\lambda_{min} \ge b$, no state $\psi$ will be accepted with probability more than $s=(1+\cos(bt))/2 + \epsilon$. The separation between $c$ and $s$ is at least 
\begin{align}
(\cos(at)-\cos(bt)) - 2\epsilon &= 2 \sin \left(\frac{(a+b)t}{2}\right) \sin \left(\frac{(b-a)t}{2}\right) - 2\epsilon \ge 2^{-\mathcal{O}(k)}
\end{align}
since $\sin x = \Omega(x)$ for $x \in [0,1]$, $(a+b)t \ge (b-a)t = 2^{-\mathcal{O}(k(n))}$, as long as we choose $\epsilon = 2^{-\Theta(k(n))}$ to be sufficiently small enough. This therefore gives a $\bddQMA{\poly}{\Theta(k(n))}{\Theta(k)}{c}{s}$ protocol for $c - s = 2^{-\mathcal{O}(k(n))}$, as desired.
\end{proof}
\subsection{$\bigcup_{c \in (0,1]}\bddQMA{\poly}{\Theta(k)}{\Theta(k)}{c}{c-2^{-\Theta(k)}}$ is in $\unitaryBQSPACE{k(n)}$} \label{subsec:bddqma-in-bqspace}
%%HERE
In this section we will establish the following result:
\begin{theorem} \label{thm: pspace upper bound}$
\bigcup_{c \in (0,1]}\bddQMA{\poly}{\Theta(k)}{\Theta(k)}{c}{c-2^{-\Theta(k)}} \subseteq \unitaryBQSPACE{\Theta(k)}$.
\end{theorem}
The results of this section have been independently obtained in \cite{fklmn16} as well using a different method (based on \cite{kln15} instead of \cite{nwz11}), with stronger results for some of the statements; for example in Lemma \ref{lem: gap amp 2} the completeness and soundness parameters of the right hand side can be replaced by $1-2^{2^{-r}}$ and $2^{2^{-r}}$, at the price of possibly increasing the time bound. Nevertheless the proof in \cite{fklmn16} is somewhat more complicated, and therefore we have included our proof in this paper.

The proof will be broken up into two steps: we first show that we can reduce the error of these small-gap $\QMA$ protocols to exponentially small in the witness size, without substantially increasing the space or witness size. Then we show that guessing a random witness suffices to distinguish the YES and NO cases with sufficient probability.
\subsubsection {In-place gap amplification of $\QMA$ protocols with phase estimation}
We start out by proving the following lemma, which proves ``in-place'' gap amplification of $\QMA$ using phase estimation.
This is very similar to Nagaj et. al's in-place gap amplification technique \cite{nwz11} (see Lemma \ref{lem: gap amp 1} in Appendix \ref{app: gap amplification}), except they use less time but more space.
\begin{lemma} \label{lem: gap amp 2}
For any functions $t,k,r>0$, 
\[
\bddQMA{t}{k}{m}{c}{s}\subseteq\bddQMA{\mathcal{O}\left(\frac{t2^r}{c-s}\right)}{\mathcal{O}\left(k+r+\log\left(\frac{1}{c-s}\right)\right)}{m}{1-2^{-r}}{2^{-r}}.
\]
\end{lemma}
\begin{proof}
	Let $L=(L_{yes}, L_{no})$ be a promise problem in $\QMA(c,s)$ and $\{V_x\}_{x\in\{0,1\}^*}$ the corresponding uniform family of verification circuits.
Define the projectors:
\begin{equation}
\Pi_0 = I_m \otimes \ket{0^k}\bra{0^k}, \quad \Pi_1 = V^\dagger_x \left(\ket{1}\bra{1}_{out} \otimes I_{m+k-1}\right) V_x
\end{equation}
and the corresponding reflections
%\begin{equation}
$R_0 = 2\Pi_0 - I, R_1 = 2\Pi_1 - I$.
%\end{equation}
Define $\phi_c = \arccos\sqrt{c}/\pi$ and $\phi_s = \arccos\sqrt{s}/\pi$ (recalling that these functions can be computed to precision $\bigoh (c-s)$ in space $\bigoh (\log[1/(c-s)])$. 
Now consider the following procedure:
\begin{compactenum}
\item Perform phase estimation of the operator $R_1R_0$ on the state $\ket{\psi}\otimes \ket{0^k}$, with precision $\bigoh (c-s)$ and failure probability $2^{-r}$.
\item Output YES if the phase is at most $(\phi_{c}+\phi_{s})/2$; otherwise output NO.
\end{compactenum}
%One way of performing phase estimation to high confidence would be to perform it to much higher precision and discard the higher order bits. 
Phase estimation of an operator $U$ up to precision $a$ and failure probability $\epsilon$ requires $\alpha := \lceil\log_2(1/a)\rceil + \log_2[2+1/(2\epsilon)]$ additional ancilla qubits and $2^\alpha = \mathcal{O}(1/(a\epsilon))$ applications of the control-$U$ operation (see e.g. \cite{nc00}).  Thus, the above procedure can be implemented by a circuit of size $\mathcal{O}(2^{r}t/(c-s))$ using $\mathcal{O}(r+\log[1/(c-s)])$ extra ancilla qubits. This procedure has completeness probability at least $1-2^{-r}$ and soundness at most $2^{-r}$.
\end{proof}

In Appendix \ref{app: gap amplification} we will prove the following stronger error reduction lemma that gives the same space bound but uses less space; this better space bound will be required for proving Theorem \ref{thm: specham-hardness}.

\begin{theorem} \label{thm: gap amp}
For any functions $t,k,r>0$, 
\[
\bddQMA{t}{k}{m}{c}{s}\subseteq\bddQMA{\mathcal{O}\left(\frac{rt}{c-s}\right)}{\mathcal{O}\left(k+r+\log\left(\frac{1}{c-s}\right)\right)}{m}{1-2^{-r}}{2^{-r}}.
\]
\end{theorem}


Thus, we get the following corollaries:
\begin{corollary} \label{obvious2} For any $r = \mathcal{O}(k)$,
$
\unitaryQSPACE{k}{c}{c-2^{-\bigoh (k)}} \subseteq
\unitaryQSPACE{\Theta(k)}{1-2^{-r}}{2^{-r}}$.
\end{corollary}
This corollary shows that error reduction is possible for unitary quantum $\bigoh(k)$-space bounded classes, as long as the completeness-soundness gap is at least $2^{-\bigoh (k)}$.
\begin{proof}
This follows from Theorem \ref{thm: gap amp} by taking $m=0$, $s = c-2^{-\Theta(k)}$, and $r = \Theta(k)$.
\end{proof}
\begin{corollary}\label{obvious1}
\[
\bddQMA{t}{k}{m}{c}{c-2^{-\Theta(k)}}\subseteq\bddQMA{\mathcal{O}\left(t2^{\Theta(k)}\right)}{\mathcal{O}\left(k\right)}{m}{1-2^{-(m+2)}}{2^{-(m+2)}}.
\]
\end{corollary}
\begin{proof}
This follows from Theorem \ref{thm: gap amp} by taking $s = c-2^{-\Theta(k)}$ and $r = m+2$.
\end{proof}
\subsubsection{Removing the witness}
\begin{theorem} \label{thm:pqpspace simulation} For any function $t=2^{\bigoh(k+m)}$,
\[
\bddQMA{t}{k}{m}{1-2^{-(m+2)}}{2^{-(m+2)}}\subseteq
\unitaryQSPACE{k+m}{3/4\cdot 2^{-m}}{1/4 \cdot 2^{-m}}.
\]
\end{theorem}
\begin{proof}
The proof is very similar to that of \cite[Theorem 3.6]{mw05}. For any functions $m, k$, consider a problem $L\in\bddQMA{\mathcal{O}\left(t2^{\Theta(k)}\right)}{\mathcal{O}\left(k\right)}{m}{1-2^{-(m+2)}}{2^{-(m+2)}}$, and let $\{V'_x\}_{x\in\{0,1\}^*}$ be a uniform family of verification circuits for $L$ with completeness $1-2^{-(m+2)}$ and soundness $2^{-(m+2)}$. 
%The acceptance probability of $V'_x$ on witness $\psi$ is
%\begin{equation}
%\left(\bra{\psi}\otimes \bra{0^p}\right) V'^\dagger_x \ket{1}\bra{1}_{out} V'_x \left(\ket{\psi}\otimes \ket{0^p}\right)
%\end{equation}
%If $x\in L_{yes}$ there exists an $m$-qubit state $\ket{\psi}$ such that
%\begin{equation}
%\left(\bra{\psi}\otimes \bra{0^p}\right) V'^\dagger_x \ket{1}\bra{1}_{out} V'_x \left(\ket{\psi}\otimes \ket{0^p}\right) \ge 1-2^{-(m+2)}
%\end{equation}
%whereas if $x \in L_{no}$, for all $m$-qubit states $\ket{\psi}$ we have
%\begin{equation}
%\left(\bra{\psi}\otimes \bra{0^p}\right) V'^\dagger_x \ket{1}\bra{1}_{out} V'_x \left(\ket{\psi}\otimes \ket{0^p}\right) \le 2^{-(m+2)}.
%\end{equation}
For convenience, define the $2^m \times 2^m$ matrix:
\begin{equation}
Q_x := \left(I_{2^m}\otimes \bra{0^p}\right) V'^\dagger_x \ket{1}\bra{1}_{out} V'_x \left(I_{2^m}\otimes \ket{0^p}\right).
\end{equation}
$Q_x$ is positive semidefinite, and $\bra{\psi}Q_x\ket{\psi}$ is the acceptance probability of $V'_x$ on witness $\psi$. Thus
\begin{equation}
x\in L_{yes} \Rightarrow \tr[Q_x]\ge 1 - 2^{-(m+2)} \ge 3/4
\end{equation}
since the trace is at least the largest eigenvalue, and $m\geq 0$; likewise,
\begin{equation}
x\in L_{no} \Rightarrow \tr[Q_x]\le 2^m \cdot 2^{-(m+2)} = 1/4
\end{equation}
since the trace is the sum of the $2^m$ eigenvalues, each of which is at most $2^{-(m+2)}$. 

Therefore our problem reduces to determining whether the trace of $Q_x$ is at least $3/4$ or at most $1/4$.  Now we will show that using the totally mixed state $2^{-m}I_m$ (alternatively, a random computational basis state) as the witness of the verification procedure encoded by $Q_x$, succeeds with the desired completeness and soundness bounds.  The acceptance probability is given by
%\begin{equation}
$\tr(Q_x 2^{-m}I_m) = 2^{-m} \tr(Q_x)$,
%\end{equation}
which is at least $2^{-m} \cdot 3/4$ if $x\in L_{yes}$, and at most $2^{-m} \cdot 1/4$ if $x\in L_{no}$. Thus we have reduced the problem $L$ to determining if a quantum computation with \emph{no} witness, acting on $k+m$ qubits, accepts with probability at least $3/4 \cdot 2^{-m}$ or at most $s'=1/4 \cdot 2^{-m}$.
\end{proof}
We can finally finish the proof of Theorem \ref{thm: pspace upper bound}.
\begin{proof}[Proof of Theorem \ref{thm: pspace upper bound}]
This follows from Corollary \ref{obvious1}, Theorem \ref{thm:pqpspace simulation}, and Corollary \ref{obvious2}.
\end{proof}

%Now we can prove the main result in this section by putting together Theorems \ref{lem:qma protocol} and \ref{thm: pspace upper bound}:
%
%\begin{corollary}\label{cor: specham-upper-bound}
%$\spechamiltonian{k(n)}\in\unitaryQSPACE{\Theta(k)}{2/3}{1/3}$.
%\end{corollary}

\subsection{$\spechamiltonian{k(n)}$ is hard for $\unitaryBQSPACE{k(n)}$}

\begin{theorem}\label{thm: specham-hardness}
$\spechamiltonian{k(n)}$ is $\unitaryBQSPACE{k(n)}$-hard under classical poly-time $k(n)$-space reductions.
\end{theorem}
\begin{proof}
Let $L=(L_{yes},L_{no})$ be a problem in $\unitaryBQSPACE{k(n)}$, and suppose it has a verifier that uses $t=2^{\bigoh(k)}$ gates with completeness $2/3$ and soundness $1/3$. By Theorem \ref{thm: gap amp}, we can   amplify the gap to get a new verifier circuit that uses $T=\mathcal{O}(rt)$ gates, and has completeness $c=1-2^{-r}$ and soundness $s=2^{-r}$. Choose $r=\bigoh(k)$ large enough so that $c \ge 1 - 1/T^3$ and $s \le 1/T^3$, and suppose $V_x=V_{x,T}V_{x,T-1}\cdots V_{x,1}$ is the new (gap-amplified) verifier circuit for $L$ acting on $k$ qubits. Consider the Kitaev clock Hamiltonian:
\begin{equation}
H = H_{in} + H_{prop} + H_{out}
\end{equation}
defined on the Hilbert space $\mathbb{C}^{2^k} \otimes \mathbb{C}^{T+1}$, where
\begin{equation}
H_{in} = \ket{0^k}\bra{0^k} \otimes \ket{0}\bra{0}, \quad
H_{out} = (\ket{1}\bra{1}_{out} \otimes I_{k-1}) \otimes \ket{T}\bra{T}
\end{equation}
\begin{equation}
H_{prop} = \sum_{j=1}^T \frac{1}{2} \left[ - V_j \otimes \ket{j}\bra{j-1} - V_j^\dagger \otimes \ket{j-1}\bra{j} + I \otimes (\ket{j}\bra{j} + \ket{j-1}\bra{j-1}) \right].
\end{equation}
$H$ is a sparse matrix - in fact, there are only a constant number of nonzero terms in each row. Since each gate $V_{x,j}$ can be computed in classical polynomial time and $k(n)$ space, it follows that so can the nonzero entries of $H$. Moreover, let $\lambda_{min}$ be the minimum eigenvalue of $H$; then it was shown by Kitaev \cite{ksv02} that if $x \in L_{yes}$ then $\lambda_{min} \le a = (1-c)/(T+1)$, while if $x \in L_{no}$ then $\lambda_{min} \ge b = (1-s)/T^3$. Since $c = 1-1/T^3$ and $s = 1/T^3$ we see that $0 < b-a < 2^{-\mathcal{O}(k)}$. 
\end{proof}
Notice that, using Watrous' result of $\BQSPACE[poly]=\PSPACE$ (our Theorem \ref{thm:pqpspace}), we can use Theorem \ref{thm: pspace upper bound} to give us that $\QMAexp\subseteq\PSPACE$ while Theorem \ref{lem:qma protocol} together with Theorem \ref{thm: specham-hardness} give us the lower bound $\PSPACE\subseteq\QMAexp$.  Therefore, we have:
\begin{corollary} $\QMAexp=\PSPACE$. \end{corollary}

Finally, we end with two results particular to the polynomial space case. First of all, in the equality $\QMAexp=\PSPACE$, we can actually achieve perfect completeness ($c=1$) for the $\QMA$ proof protocol. Moreover for perfect completeness we do not require that $c-s = 2^{-\poly}$:
\begin{proposition} \label{prop: perfect completeness} Let $\QMA(c,s) = \bddQMA{\poly}{\poly}{\poly}{c}{s}$. Then
\[
\PSPACE = \QMA(1,1-2^{-\poly}) = \bigcup_{s \in [0,1)}\QMA(1,s).
\]
\end{proposition}
The containment $\QMA(1,s) \subseteq \PSPACE$ is known \cite{ikw12}. We prove this proposition in Appendix~\ref{app:perfectcompleteness}.

Our second result concerns the $\QMA$-complete Local Hamiltonian problem. We consider the variant of the local Hamiltonian problem where the promise gap is only exponentially small: 
\begin{definition}[\preciseklh]
Given as input is a $k$-local Hamiltonian $H=\sum_{j=1}^rH_j$ acting on $n$ qubits, satisfying $r \in \poly(n)$ and $\|H_j\| \le \poly(n)$, and numbers $a < b$ satisfying $b - a > 2^{-\poly(n)}$. It is promised that the smallest eigenvalue of $H$ is either at most $a$ or at least $b$. Output 1 if the smallest eigenvalue of $H$ is at most $a$, and output 0 otherwise.
\end{definition}
Our result is that this problem is $\PSPACE$-complete:
\begin{theorem} \label{thm: precise local hamiltonian}
For any $3 \le k \le \mathcal{O}(\log(n))$, \preciseklh \ is $\QMAexp$-complete, and hence $\PSPACE$-complete.
\end{theorem}
We note that this can be seen as restricting $H$ in the $\spechamiltonian{\poly(n)}$ problem to be a local Hamiltonian; our result is that this problem remains $\PSPACE$-hard. For a proof, see Appendix \ref{app:localhamiltonian}.

\section{Open Problems}
This work leaves open several questions that may lead to interesting follow-up work:
\begin{compactenum}
\begin{item} Can we use our $\QMAexp=\PSPACE$ result to prove upper or lower bounds for other complexity classes? \end{item}
\begin{item} Here we have shown $\QMAexp=\PSPACE$.  Ito, Kobayashi and Watrous  have shown that $\QIP$ with doubly-exponentially small completeness-soundness gap is equal to $\EXP$ \cite{ikw12}.  What can be said about the power of $\QIP$ with exponentially small completeness-soundness gap?\end{item}
\begin{item}In this paper we studied unitary quantum space complexity classes, and showed that \matrixinvert{k(n)} and \spechamiltonian{k(n)} characterize unitary quantum space complexity.  Can similar hardness results be shown for non-unitary quantum space complexity classes?\end{item}
\end{compactenum}


\section{Acknowledgements}
We are grateful to Andrew Childs, Sevag Gharibian, Aram Harrow, Hirotada Kobayashi, Tomoyuki Morimae, Harumichi Nishimura, Martin Schwarz, John Watrous, and Xiaodi Wu for helpful conversations, and to John Watrous for comments on a preliminary draft. This work was supported by the Department of Defense.

 \bibliography{completespace}
\bibliographystyle{plain}

\appendix

\section{More details on space-bounded computation}\label{app: space bounded}
We start with the definitions of classical bounded space computation. In discussion of space-bounded classes, we usually consider Turing machines with two tapes, a read-only input tape and a work tape; only the space used on the work tape is counted. For $k:\mathbb{N}\rightarrow\mathbb{N}$, a function $f:\{0,1\}^{*}\rightarrow\{0,1\}^*$ is said to be computable in $k(n)$ space if any bit of $f(x)$ can be computed by a deterministic Turing machine using space $\bigoh(k(|x|))$ on the work tape.  For example, $\Logspace$ is the class of functions that can be computed in $\bigoh(\log{n})$ space.

We now discuss quantum space-bounded complexity classes; for a fuller discussion see \cite{Watrous09}. A straightforward way to define quantum space-bounded classes is to consider a Turing machine with three tapes: a read-only classical input tape, a classical work tape, and a quantum work tape (with two heads) consisting of qubits. This is the model considered in \cite{tashma} and \cite{Watrous03}, except that they allow intermediate measurements (and \cite{Watrous03} allows even more general quantum operations). In this work we consider only computations with no intermediate measurements: we can therefore impose that there are no measurements on the quantum work tape until the register reaches a specified end state, following which a single measurement is performed on the quantum tape and the algorithm accepts or rejects according to the measurement. Therefore the operations performed by the algorithm will not depend on the quantum tape, since there is no way to read information out of it until the end of the algorithm.

Instead of working with Turing machines, in quantum computation it is much more customary (and convenient) to work with quantum circuits. For the setup above, since the operations on the quantum tape are completely classically controlled, we can equivalently consider a quantum circuit generated by a classical space-bounded Turing machine that computes the quantum gates one-by-one and applies them in sequence. If the classical Turing machine is $\mathcal{O}(k(n))$-space bounded, it has at most $2^{\mathcal{O}(k)}$ configurations, and therefore there are at most $2^{\mathcal{O}(k)}$ quantum gates in the circuit. 

Moreover, the $\mathcal{O}(k)$-space bounded classical Turing machine can be replaced by a classical circuit on $\mathcal{O}(k)$ bits, such that there is a $\poly(n)$-time $\mathcal{O}(k)$-space Turing machine that on input $i$ generates the $i$-th gate of the circuit (see e.g. \cite[Section~6.8]{ab09}). The classical circuit can then be bundled into the quantum circuit, and we obtain a quantum circuit with at most $2^{\mathcal{O}(k)}$ gates, such that each individual gate can be generated in classical $\poly(n)$-time and $\mathcal{O}(k)$-space. This justifies the definition of the complexity class $\QSPACE[k(n)](c,s)$:

\begingroup
\def\thedefinition{\ref{def: qspace}}
\begin{definition}
We say a promise problem $L=(L_{YES},L_{NO})$ is in $\QSPACE[k(n)](c,s)$ if there exists a $\poly(|x|)$-time $\mathcal{O}(k)$-space uniformly generated family of quantum circuits $\{Q_x\}_{x\in\{0,1\}^*}$, where each circuit $Q_x=U_{x,T}U_{x,T-1}\cdots U_{x,1}$ has $T=2^{\mathcal{O}(k)}$ gates, and acts on $\mathcal{O}(k(|x|))$ qubits, such that:\\
 If $x \in L_{yes}$:
\begin{equation}
\bra{0^k} Q^\dagger_x \ket{1}\bra{1}_{out} Q_x \ket{0^k} \ge c.
\end{equation}
Whereas if $x \in L_{no}$:
\begin{equation}
\bra{0^k} Q^\dagger_x \ket{1}\bra{1}_{out} Q_x \ket{0^k} \le s.
\end{equation}
Here $out$ denotes a single qubit we measure at the end of the computation; no intermediate measurements are allowed.  
Furthermore, we require $c$ and $s$ to be computable in classical $\bigoh(k(n))$-space.
%For the purposes of this work, we will demand that the space bound $k(n)$ is at least $\bigoh(\log{n})$ and no more than $2^{\poly(n)}$.  
\end{definition}
\addtocounter{theorem}{-1}
\endgroup

\section{Proof sketch of $\PQP^{O_{PEPS}}_{\parallel,\text{classical}} = \PP$} \label{app:peps}
Since $\PP \subseteq \BQP^{O_{PEPS}}_{\parallel,\text{classical}} \subseteq \PQP^{O_{PEPS}}_{\parallel,\text{classical}}$ \cite{swv07}, we only need to show that $\PQP^{O_{PEPS}}_{\parallel,\text{classical}} \subseteq \PP$. In \cite{swv07} it was noted that all PEPS can be seen as the output of a quantum circuit followed by a postselected measurement. Therefore $\PQP^{O_{PEPS}}_{\parallel,\text{classical}}$ corresponds to the problems that can be decided by a quantum circuit, followed by a postselected measurement (since the queries to $O_{PEPS}$ are classical and nonadaptive, we can compose them into one single postselection), followed by a measurement. In the YES case the measurement outputs 1 with probability at least $c$, whereas in the NO case the measurement outputs 1 with probability at most $s$, with $c > s$. The standard counting argument placing $\BQP$ inside $\PP$ then applies to this case as well; see for instance \cite[Propositions~2~and~3]{aaronson05}.
\section{Achieving Perfect Completeness for $\QMAexp$}\label{app:perfectcompleteness}
%\begin{definition}We say a promise problem $L=(L_{yes},L_{no})$ is in $\revPSPACE$ (reversible polynomial space) if it can be decided by a polynomial space reversible Turing machine, i.e., a machine in which every configuration has at most one immediate predecessor.  	
%\end{definition}
%
%\begin{theorem}[Bennett\cite{bennett89}]\label{thm:revpspace}$\revPSPACE=\PSPACE$.
%\end{theorem}
We now consider the problem of achieving prefect completeness for $\QMAexp$. Specifically, we will show the following:
\begin{proposition} Let $\QMA(c,s) = \bddQMA{\poly}{\poly}{\poly}{c}{s}$. Then
\[
\PSPACE = \QMA(1,1-2^{-\poly}) = \bigcup_{s \in [0,1)}\QMA(1,s).
\]
\end{proposition}
Since $\PSPACE = \QMAexp$, this proposition shows that any $\QMAexp$ protocol can be reduced to a different $\QMAexp$ protocol with perfect completeness, i.e. in the YES case Arthur accepts Merlin's witness with probability 1. The reduction is rather roundabout, however, and it would be interesting to see if a more direct reduction can be found.

The second equality follows from the first equality and the result by \cite{ikw12} that $\QMA(1,s) \subseteq \PSPACE$. We will therefore only prove the first equality.

Looking back at Circuit \ref{circ: poor man phase estimation}, we see that we \emph{almost} have perfect completeness in our protocol already - if the Hamiltonian simulation of $e^{-iHt}$ could be done without error, then indeed the protocol has perfect completeness. Our strategy will be perform a different unitary that can be performed exactly, but, like $e^{-iHt}$, also allows us to use phase estimation to distinguish the eigenvalues of $H$.

Given a sparse Hamiltonian $H$ (with at most $d$ nonzero entries per row) and a number $X \ge \max_{j,\ell}|H_{j\ell}|$ that upper bounds the absolute value of entries of $H$, Andrew Childs defined an efficiently implementable quantum walk \cite{berry14,childs10}. Each step of the quantum walk is a unitary $U$ with eigenvalues $e^{i\tilde{\lambda}}$, where 
\begin{equation}
\tilde{\lambda} = \arcsin \frac{\lambda}{Xd}
\end{equation}
with $\lambda$ representing eigenvalues of $H$. Note that the YES case $\lambda = 0$ corresponds to $\tilde{\lambda}=0$, and the NO case $\lambda \ge 2^{-g(n)}$ corresponds to $\tilde{\lambda} \ge 2^{-g(n)}/(Xd)$ since $\arcsin x \ge x$ for $|x| \le 1$. In the latter case the $\tilde{\lambda}$ can be at most exponentially small, and therefore the stripped down version of phase estimation still suffices to tell the two cases apart with exponentially small probability.

We now note that the Hamiltonian $H$ we obtain from the hardness reduction from $\PSPACE$ (Theorem \ref{thm: specham-hardness}) is of a very special form. Specifically, since $\unitaryBQSPACE{\poly}=\PSPACE$, we can assume the verifier circuit $V_x$ is deterministic, so it has completeness 1 and soundness 0. Moreover, all of its gates are classical, and hence all entries of the Kitaev clock Hamiltonian $H$ are $0$, $\pm 1/2$, or $1$.

For the matrix $H$ satisfying the above, $U$ can be implemented exactly with a standard gateset; perfect completeness of the protocol will then follow. If $H$ is a $N \times N$ matrix (where $N=2^n$), $U$ is (see presentation in \cite[Section~3.1~and~Lemma~10]{berry15}) a unitary defined on the enlarged Hilbert space $\mathbb{C}^{2N} \otimes \mathbb{C}^{2N} = (\mathbb{C}^{N} \otimes \mathbb{C}^2) \otimes  (\mathbb{C}^{N} \otimes \mathbb{C}^2)$, as follows:
\begin{equation}
U = ST(I_{2N} \otimes (I_{2N} - 2\ket{0}\bra{0}_{2N})) T^\dagger
\end{equation}
where the $2N$ subscript indicates a register of dimension $2N$, the unitary $S$ swaps the two registers, and the unitary $T$ is defined by
\begin{equation}
T = \sum_{j=0}^{N-1}\sum_{b \in \{0,1\}} (\ket{j}\bra{j} \otimes \ket{b}\bra{b}) \otimes \ket{\varphi_{jb}}\bra{0}_{2N}
\end{equation}
with $\ket{\varphi_{j1}} = \ket{0}_N\ket{1}$ and
\begin{equation}
\ket{\varphi_{jb}} = \frac{1}{\sqrt{d}} \sum_{\ell \in F_j} \ket{\ell}\left(\sqrt{\frac{H^*_{j\ell}}{X}}\ket{0} + \sqrt{1-\frac{|H^*_{j\ell}|}{X}}\ket{1}\right),
\end{equation}
where $F_j$ index the nonzero entries in the $j$-th row. Recall that for any $j,\ell$, $H_{j\ell}=0$, $\pm 1/2$, or $1$, and hence we can take $X=1$. If we furthermore assume $d$ is a power of 2 (which we can always do by adding indices of zero entries to $F_j$), it is straightforward to see that both $S$ and $T$ can be implemented using just Hadamard gates and classical gates (Pauli-$X$, controlled-$X$, and Toffoli gates). Therefore $U$ can be exactly implemented in any gateset that allows Hadamard gates and classical gates to be implemented exactly.

\section{Precise Local Hamiltonian Problem}\label{app:localhamiltonian}
Recall the following definition:
\begin{definition}[\preciseklh]
Given as input is a $k$-local Hamiltonian $H=\sum_{j=1}^rH_j$ acting on $n$ qubits, satisfying $r \in \poly(n)$ and $\|H_j\| \le \poly(n)$, and numbers $a < b$ satisfying $b - a > 2^{-\poly(n)}$. It is promised that the smallest eigenvalue of $H$ is either at most $a$ or at least $b$. Output 1 if the smallest eigenvalue of $H$ is at most $a$, and output 0 otherwise.
\end{definition}
In this section we will prove the following:
\begin{theorem}
For any $3 \le k \le \mathcal{O}(\log(n))$, \preciseklh \ is $\QMAexp$-complete, and hence $\PSPACE$-complete.
\end{theorem}
\begin{proof}
This proof follows straightforwardly by adapting the proof of \cite{ksv02} and \cite{kr03}. The proof of containment in $\QMAexp$ is identical to the containment of the usual Local Hamiltonian problem in $\QMA$; see \cite{ksv02} for details.

To show $\QMAexp$-hardness, we note that for a $\QMA$-verification procedure with $T$ gates, completeness $c$ and soundness $s$, \cite{kr03} reduces this to a 3-local Hamiltonian with lowest eigenvalue no more than $(1-c) / (T+1)$ in the YES case, or no less than $(1-s) / T^3$ in the NO case. For this to specify a valid \preciselh \ problem we need that
\begin{equation} \label{eq:preciselh_condition}
\frac{1-s}{T^3} - \frac{1-c}{T+1} > 2^{-\poly(n)}.
\end{equation}
Recalling that we showed that perfect completeness can be assumed for $\QMAexp$-hard problems, we can take $c=1$, $s = 1-2^{-\poly(n)}$ and the above inequality trivially holds. Hence any problem in $\PSPACE$ can be reduced to a \preciseilh{3} problem.
\end{proof}
In fact, even just testing whether a $k$-Local Hamiltonian is frustration-free is $\PSPACE$-complete: \begin{definition} [\emph{Frustration-Free $k$-Local Hamiltonian}] Given as input is a $k$-local Hamiltonian $H=\sum_{j=1}^rH_j$ acting on $n$ qubits, satisfying $r \in \poly(n)$, each term $H_j$ is positive semidefinite, and $\|H_j\| \le \poly(n)$. Output 1 if the smallest eigenvalue of $H$ is zero, and output 0 otherwise.
\end{definition}
\begin{theorem}
Frustration-Free $k$-Local Hamiltonian is $\PSPACE$-complete.
\end{theorem}
\begin{proof}
The containment in $\PSPACE$ follows from the proof of the containment of the usual Local Hamiltonian problem in $\QMA$ \cite{ksv02}, along with Proposition \ref{prop: perfect completeness}. $\PSPACE$-hardness follows from the proof of Theorem \ref{thm: precise local hamiltonian}, by taking $c=1$ in the proof.
\end{proof}

\section{$\qca{k(n)}$ is $\unitaryBQSPACE{k(n)}$-hard}\label{app:qca}
\begingroup
\def\thelemma{\ref{lem: quantum circuit acceptance}}
\begin{lemma}
$\qca{k(n)}$ is $\unitaryBQSPACE{k(n)}$-hard under classical polynomial time, $k(n)$ space reductions.
\end{lemma}
\addtocounter{theorem}{-1}
\endgroup

\begin{proof}This lemma is implicit in e.g., \cite{bbbv,dawsonnielsen}.  We include the proof here for completeness.  Suppose we are given an $x\in \{0,1\}^n$ and would like to determine if $x\in L_{yes}$ for some $L=\{L_{yes},L_{no}\}\in\unitaryBQSPACE{k}$.  There is a quantum circuit on $k(n)$ qubits, $Q_x=U_TU_{T-1}\cdots U_1$ of size $T=2^{\mathcal{O}(k(n))}$ that decides $x$.  That is, 
\begin{equation}
Q_x|\zero\rangle = \sqrt{p_x} |1\rangle_{out}|\psi_x^1\rangle + \sqrt{1-p_x} |0\rangle_{out} |\psi_x^0\rangle.
\end{equation}
where $out$ indicates the designated output qubit, and $|\psi_x^1\rangle$, $|\psi_x^0\rangle$ are $(k-1)$-qubit states; $p_x$ is the probability that the computation accepts, so $p_x \ge 2/3$ if $x \in L_{yes}$ and $p_x \le 1/3$ if $x \in L_{no}$.

We now describe a reduction which creates a related circuit $\tilde{Q}_x$ with a single matrix entry that is proportional to the acceptance probability of $Q_x$.  This new circuit $\tilde{Q}_x$ takes the same number of input qubits as $Q_x$ as well as an additional ancillary qubit.  $\tilde{Q}_x$ runs $Q_x$, then using a single CNOT gate copies the state of the output qubit to the ancillary qubit, flips the ancillary qubit, and finally applies the inverse, $Q_x^{\dagger}$, to the input qubits. It is straightforward to check that
\begin{equation}
\langle 0|\langle \zero|\tilde{Q}_x|\zero\rangle|0\rangle = p_x.
\end{equation}
Therefore knowing the single matrix entry $\langle 0|\langle \zero|\tilde{Q}_x|\zero\rangle|0\rangle$ is sufficient to decide if $x \in L_{yes}$. Moreover, $\tilde{Q}_x$ can be computed from $Q_x$ using polynomial time and $\mathcal{O}(k)$ space, and this completes the proof.
\end{proof}

\section{In-place gap amplification} \label{app: gap amplification}
In this appendix we will prove Theorem \ref{thm: gap amp}. To do so we first start out with the following weaker result:
\begin{lemma}[Implicit in Nagaj, Wocjan, and Zhang \cite{nwz11}] \label{lem: gap amp 1}
For any functions $t,k,r>0$, 
\[
\bddQMA{t}{k}{m}{c}{s}\subseteq\bddQMA{\mathcal{O}\left(\frac{rt}{c-s}\right)}{\mathcal{O}\left(k+r\log\left(\frac{1}{c-s}\right)\right)}{m}{1-2^{-r}}{2^{-r}}.
\]
\end{lemma}
\begin{proof}
	Let $L=(L_{yes}, L_{no})$ be a promise problem in $\QMA(c,s)$ and $\{V_x\}_{x\in\{0,1\}^*}$ the corresponding uniform family of verification circuits.
Define the projectors:
\begin{align}
\Pi_0 &= I_m \otimes \ket{0^k}\bra{0^k} \\
\Pi_1 &= V^\dagger_x \left(\ket{1}\bra{1}_{out} \otimes I_{m+k-1}\right) V_x
\end{align}
and the corresponding reflections:
\begin{equation}
R_0 = 2\Pi_0 - I, \quad R_1 = 2\Pi_1 - I.
\end{equation}
Define $\phi_c = \arccos\sqrt{c}/\pi$ and $\phi_s = \arccos\sqrt{s}/\pi$ (recalling that these functions can be computed to precision $\bigoh (c-s)$ in space $\bigoh (\log[1/(c-s)])$. 
Now consider the following procedure:
\begin{compactenum}
\item Perform $r$ trials of phase estimation of the operator $R_1R_0$ on the state $\ket{\psi}\otimes \ket{0^k}$, with  precision $\mathcal{O}(c-s)$ and $1/16$ failure probability. 
\item If the median of the $r$ results is at most $(\phi_{c}+\phi_{s})/2$, output YES; otherwise output NO.
\end{compactenum}
Phase estimation of an operator $U$ up to precision $a$ and failure probability $\epsilon$ requires $\alpha := \lceil\log_2(1/a)\rceil + \log_2[2+1/(2\epsilon)]$ additional ancilla qubits and $2^\alpha = \mathcal{O}(1/(a\epsilon))$ applications of the control-$U$ operation (see e.g. \cite{nc00}).  Thus, the above procedure, which uses $r$ applications of phase estimation to precision $\mathcal{O}(c-s)$, can be implemented by a circuit of size $\mathcal{O}(rt/(c-s))$ using $\mathcal{O}(r\log[1/(c-s)])$ extra ancilla qubits. Using the standard analysis of in-place $\QMA$ error amplification \cite{mw05,nwz11}, it can be seen that this procedure has completeness probability at least $1-2^{-r}$ and soundness at most $2^{-r}$.
\end{proof}
We can now prove Theorem \ref{thm: gap amp}, which we restate below:
\begingroup
\def\thetheorem{\ref{thm: gap amp}}
\begin{theorem}
For any functions $t,k,r>0$, 
\[
\bddQMA{t}{k}{m}{c}{s}\subseteq\bddQMA{\mathcal{O}\left(\frac{rt}{c-s}\right)}{\mathcal{O}\left(k+r+\log\left(\frac{1}{c-s}\right)\right)}{m}{1-2^{-r}}{2^{-r}}.
\]
\end{theorem}
\addtocounter{theorem}{-1}
\endgroup

\begin{proof}
\begin{align}
\bddQMA{t}{k}{m}{c}{s} &\subseteq \bddQMA{\mathcal{O}\left(\frac{t}{c-s}\right)}{\mathcal{O}\left(k+\log\left(\frac{1}{c-s}\right)\right)}{m}{3/4}{1/4}  \nonumber \\
&\subseteq \bddQMA{\mathcal{O}\left(\frac{rt}{c-s}\right)}{\mathcal{O}\left(k+r+\log\left(\frac{1}{c-s}\right)\right)}{m}{1-2^{-r}}{2^{-r}} \nonumber
\end{align}
where the first line follows by taking $r=2$ in Lemma \ref{lem: gap amp 2}, and the second line follows from Lemma~\ref{lem: gap amp 1}.
\end{proof}

\section{Proof that \matrixinvert{\bigoh(k(n)} $\in \unitaryBQSPACE{k(n)}$}\label{app: matrix inversion alg}

\begingroup
\def\thetheorem{\ref{thm: matrix inversion alg}}
\begin{theorem}
Fix functions $k(n)$, $\kappa(n)$, and $\epsilon(n)$. Suppose we are given the size-$n$ efficient encoding of a $2^{k(n)} \times 2^{k(n)}$ PSD matrix $H$ such that $\kappa^{-1} I \preceq H \preceq I$. We are also given $\poly(n)$-time $\mathcal{O}(k+\log(\kappa/\epsilon))$-space uniform quantum circuits $U_a$ and $U_b$ acting on $k$ qubits. Let $U_a\ket{0}^{\otimes k(n)} = \ket{a}$ and $U_b\ket{0}^{\otimes k(n)} = \ket{b}$. The following tasks can be performed with $\poly(n)$-time $O(k+\log(\kappa/\epsilon))$-space uniform quantum circuits over $\bigoh (k+\log(\kappa/\epsilon))$ qubits:
\begin{compactenum}
\item With at least constant probability, output an approximation of the quantum state $H^{-1}\ket{b} / \|H^{-1}\ket{b}\|$ up to error $\epsilon$.
\item Estimate $\|H^{-1}\ket{b}\|$ up to precision $\epsilon$.
\item Estimate  $|\bra{a}H^{-1}\ket{b}|$ up to precision $\epsilon$.
\end{compactenum}
These circuits do not require intermediate measurements.
\end{theorem}
\addtocounter{theorem}{-1}
\endgroup

\begin{proof}
We first show the first item, i.e. generating the state $H^{-1}\ket{b} / \|H^{-1}\ket{b}\|$. Choose $\epsilon' = \mathcal{O}(\epsilon/\kappa)$ in the statement of Lemma \ref{lem: matrix inversion lemma}, keeping in mind for the rest of the proof that $\log(\kappa/\epsilon') = \mathcal{O}(\log(\kappa/\epsilon))$. Note that $\ket{\psi_b}$ can be obtained by computing $W_HU_b\ket{0}_{all} = W_H (\ket{0}_{anc} \otimes \ket{b})$, and then postselecting on the output qubit being in state $\ket{0}$. To obtain $\ket{\psi_b}$ with high probability we can repeat this procedure many times until success. We can then get a good approximation to $\frac{H^{-1}\ket{b}} {\|H^{-1}\ket{b}\|} $ by tracing out the other ancilla qubits. For our setting we would like to get by with a low space requirement and without using intermediate measurements, so instead of repeating until success, we will apply amplitude amplification to the above unitary $W_H$. Define the projectors $\Pi_0$ and $\Pi_1$ by
\begin{align}
\Pi_0 &= \ket{0}\bra{0}_{anc} \otimes \ket{b}\bra{b} \\
\Pi_1 &= W_H^\dagger (\ket{0}\bra{0}_{out} \otimes I) W_H
\end{align}
Define $\ket{v} = \ket{0}_{anc}\otimes \ket{b}$, and write
\begin{align}
\ket{v} &= \sin \theta \ket{w} +\cos \theta\ket{w^\perp}, \\
\ket{w} &= \sin \theta \ket{v} + \cos \theta\ket{v^\perp}
\end{align}
where $\ket{v^\perp}$, $\ket{w}$, and $\ket{w^\perp}$ are normalized states such that 
\begin{align}
\Pi_0\ket{v} = \ket{v},&\quad \Pi_0\ket{v^\perp} = 0 \\
\Pi_1\ket{w} = \ket{w},&\quad \Pi_1\ket{w^\perp} = 0.
\end{align}
Note that
\begin{equation} 
(\bra{0}_{anc} \otimes I) W_H (\ket{0}\bra{0}_{anc} \otimes \ket{b}\bra{b}) (\ket{0}_{anc} \otimes \ket{b}) = W_H \Pi_1\Pi_0(\ket{0}_{anc} \otimes \ket{b}) \propto W_H \ket{w},
\end{equation}
and therefore $W_A\ket{w}$ is the postmeasurement state we desire. The success probability of the postselection step is simply $\bra{v}\Pi_0\Pi_1\Pi_0\ket{v} = \alpha^2 = \sin^2\theta$. 

Consider now the rotation operator $R=-(I-2\Pi_0)(I-2\Pi_1)$; it is straightforward to verify that for any $\phi$,
\begin{equation}
R[\sin(\phi) \ket{w} + \cos(\phi) \ket{w^\perp}] = \sin(\phi + 2\theta) \ket{w} + \cos(\phi + 2\theta) \ket{w^\perp}.
\end{equation}
Therefore if we start from $\ket{v}$ and apply the rotation $R$ a total of
\begin{equation}
\frac{\pi}{4\theta} - \frac{1}{2}
\end{equation}
times, the resulting quantum state will be close to $\ket{w}$. Here recall $\theta = \sin^{-1}\alpha$. Projecting into the image of $\Pi_1$ and then applying $W_H$ will then give the desired postmeasurement state $W_H\ket{w}$. To do this, however, we need to know what $\theta$ is. Since $R$ is a rotation on the two-dimensional subspace spanned by $\{\ket{v},\ket{w}\}$ with rotation angle $2\theta$, $R$ has eigenvalues $\exp(\pm i2\theta)$ in this subspace. Performing phase estimation on $R$ will therefore give an estimate of $\theta/\pi$. We would like to obtain an estimate $\gamma$ such that 
\begin{equation} \label{eq: gamma}
\left|\frac{\gamma\pi}{\theta} - 1\right| \le  \frac{\epsilon'}{2}
\end{equation}
holds with probability $1-\poly(\epsilon' / \kappa)2^{-\mathcal{O}(k)}$.

We now look at the space requirements of phase estimation. First of all, note that since both $W_H$ and $U_b$ are circuits on at most $\bigoh (k + \log(\kappa/\epsilon))$ qubits, $R$ also only requires $\bigoh (k + \log(\kappa/\epsilon))$ space. Also, we have that
\begin{align}
\alpha &\ge \frac{\|A^{-1}\ket{b}\|}{\kappa} - \epsilon' \\
&\ge \frac{1}{\kappa} - \epsilon'.
\end{align}
Since we can always take $\epsilon' \le 1/(2\kappa)$ (this doesn't change the space guarantee of $\bigoh (k+\log(\kappa/\epsilon))$ in Theorem 1), phase estimation of $R$ to precision $\poly(\epsilon/\kappa)$ suffices to output an $\gamma$ such that (\ref{eq: gamma}) holds. To do so with failure probability $\poly(\epsilon \kappa^{-1}2^{-\mathcal{O}(k)})$ requires at most $\bigoh(k+\log(\kappa/\epsilon))$ extra ancilla qubits.

Finally, we apply the rotation $R$ to $\ket{v} = \sin \theta \ket{w} +\cos \theta\ket{w^\perp}$ a total of $\lfloor1/(4\gamma)\rfloor$ times. The resulting state is
\begin{equation}
R^{\lfloor1/(4\gamma)\rfloor}\ket{v} = \sin\left[\left(2\left\lfloor\frac{1}{4\gamma}\right\rfloor+1\right)\theta\right] \ket{w} + \cos\left[\left(2\left\lfloor\frac{1}{4\gamma}\right\rfloor+1\right)\theta\right] \ket{w^\perp}
\end{equation}
(\ref{eq: gamma}) implies $|\theta/(\pi\gamma) - 1| \le \epsilon'$ (as long as $\epsilon' \le 1/2$), and a straightforward calculation shows that $|(2\lfloor1/(4\gamma)\rfloor+1) \theta - \pi/2| \le \frac{\pi}{2}+\theta$. Therefore as long as $\theta \le \pi/4$, the resulting state will have constant overlap with $\ket{w}$, and our procedure will succeed with constant probability (which we can verify by applying the projection $\Pi_1$). If instead $\theta > \pi/4$ (as we can determine from our estimate $\gamma$), we can perform the projection $\Pi_1$ to the initial state $\ket{v}$ directly and succeed with constant probability.

Note that in the process we have also calculated an estimate for $\theta = \sin^{-1}\alpha$ up to $\bigoh(\epsilon')$ error, and since $|\alpha - \frac{\|H^{-1}\ket{b}\|}{\kappa}| \le \epsilon'$ we can also output an estimate for $\|H^{-1}\ket{b}\|$ up to precision $\mathcal{O}(\kappa \epsilon') = \mathcal{O}(\epsilon)$.

Finally, if an estimate for $|\bra{a} H^{-1} \ket{b}|$ is desired, we can consider instead the following modification to $\Pi_0$ and $\Pi_1$:
\begin{align}
\Pi_0 &= \ket{0}\bra{0}_{anc} \otimes \ket{b}\bra{b} \\
\Pi'_1 &= W_H^\dagger (\ket{0}\bra{0}_{out} \otimes I) (I_{anc} \otimes \ket{a}\bra{a})(\ket{0}\bra{0}_{out} \otimes I) W_H
\end{align}
Since $(\ket{0}\bra{0}_{out} \otimes I) W_H (\ket{0}^{\otimes \ell} \otimes \ket{b}) = \alpha \ket{0}_{out} \otimes \ket{\psi_b}$, we see that 
\begin{equation}
\bra{v}\Pi_0\Pi_1\Pi_0\ket{v} = \alpha^2\left|\left(\bra{0}^{\otimes \ell-1} \otimes \bra{a}\right) \ket{\psi_b}\right|^2.
\end{equation}
$\bra{v}\Pi_0\Pi_1\Pi_0\ket{v}$ can be estimated in the same way that $\alpha$ has been estimated. Recalling that $\| \ket{\psi_b} - \ket{0}^{\otimes \ell-1} \otimes \frac{H^{-1}\ket{b}} {\|H^{-1}\ket{b}\|} \| \le \epsilon'$ and $|\alpha - \frac{\|H^{-1}\ket{b}\|}{\kappa}| \le \epsilon'$, this allows us to estimate $|\bra{a} H^{-1} \ket{b}|$ to $\bigoh (\epsilon)$ precision.
\end{proof}

\end{document}
